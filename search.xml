<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>stm32_uart卡在等待发送移位寄存器为空</title>
      <link href="/blog/2021/05/09/stm32-uart%E5%8D%A1%E5%9C%A8%E7%AD%89%E5%BE%85%E5%8F%91%E9%80%81%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%BA%E7%A9%BA/"/>
      <url>/blog/2021/05/09/stm32-uart%E5%8D%A1%E5%9C%A8%E7%AD%89%E5%BE%85%E5%8F%91%E9%80%81%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%BA%E7%A9%BA/</url>
      
        <content type="html"><![CDATA[<p>整理文件发现了当时用32的uart时候的这个随手笔记</p><p>用的是z8t6，贴一下。。其实可读性很差基本上只有当初自己知道自己在说啥。。。以后再遇到了来翻一下。。</p><h3 id="板载资源"><a href="#板载资源" class="headerlink" title="板载资源"></a>板载资源</h3><p>三个usart  通用同步异步<br>俩uart 异步</p><h3 id="串口时钟使能"><a href="#串口时钟使能" class="headerlink" title="串口时钟使能"></a>串口时钟使能</h3><p>串口是挂载在 APB2 下面的外设，所以使能函数为：</p><pre><code>RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1)；</code></pre><h3 id="串口复位"><a href="#串口复位" class="headerlink" title="串口复位"></a>串口复位</h3><p>当外设出现异常的时候可以通过复位设置，实现该外设的复位，然后重新配置这个外设达到让其重新工作的目的。一般在系统刚开始配置外设的时候，都会先执行复位该外设的操作。 复位的是在函数 USART_DeInit()中完成：</p><pre><code>void USART_DeInit(USART_TypeDef* USARTx);//串口复位</code></pre><h3 id="串口参数初始化"><a href="#串口参数初始化" class="headerlink" title="串口参数初始化"></a>串口参数初始化</h3><p>串口初始化是通过 USART_Init()函数实现的，</p><pre><code>void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)；</code></pre><h3 id="数据发送与接收"><a href="#数据发送与接收" class="headerlink" title="数据发送与接收"></a>数据发送与接收</h3><p> STM32 的发送与接收是通过数据寄存器 USART_DR 来实现的，这是一个双寄存器，（低八位有效，他位保留）包含了 TDR 和 RDR(一条总线出来 地址一样  但是其实有俩，移位寄存器也是有俩  ，这种设计是为了防止全双工通信的时候对发导致冲突)。当向该寄存器写数据的时候，串口就会立刻自动发送，不会保存下来，当收到数据的时候，也是存在该寄存器内。</p><p>STM32 库函数操作 USART_DR 寄存器发送数据的函数是：</p><pre><code>void USART_SendData(USART_TypeDef* USARTx, uint16_t Data);</code></pre><p>通过该函数向串口寄存器 USART_DR 写入一个数据。</p><p>STM32 库函数操作 USART_DR 寄存器读取串口接收到的数据的函数是：</p><pre><code>uint16_t USART_ReceiveData(USART_TypeDef* USARTx);</code></pre><h3 id="串口状态"><a href="#串口状态" class="headerlink" title="串口状态"></a>串口状态</h3><p>串口的状态可以通过状态寄存器 USART_SR 读取。USART_SR 的各位描述见数据手册</p><p>这里我们关注一下两个位，第 5、 6 位 RXNE 和 TC。</p><p>RXNE（读数据寄存器非空），当该位被置 1 的时候，就是提示已经有数据被接收到了，并且可以读出来了。这时候我们要做的就是尽快去读取 USART_DR，通过读 USART_DR 可以将该位清零，也可以向该位写 0，直接清除。</p><p>TC（发送完成），当该位被置位的时候，表示 USART_DR 内的数据已经被发送完成了。如果设置了这个位的中断，则会产生中断。该位也有两种清零方式： 1）读 USART_SR，写USART_DR。 2）直接向该位写 0。</p><p>在我们固件库函数里面，读取串口状态的函数是：</p><pre><code>FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)；</code></pre><p>这个函数的第二个入口参数非常关键， 它是标示我们要查看串口的哪种状态， 比如上面讲解的RXNE(读数据寄存器非空)以及 TC(发送完成)。例如我们要判断读寄存器是否非空(RXNE)， 操作库函数的方法是：</p><pre><code>USART_GetFlagStatus(USART1, USART_FLAG_RXNE);</code></pre><p>我们要判断发送是否完成(TC)，操作库函数的方法是：</p><pre><code>USART_GetFlagStatus(USART1, USART_FLAG_TC);</code></pre><p>这些标识号在 MDK 里面是通过宏定义定义的：</p><p>#define USART_IT_PE ((uint16_t)0x0028)<br>#define USART_IT_TXE ((uint16_t)0x0727)<br>#define USART_IT_TC ((uint16_t)0x0626)<br>#define USART_IT_RXNE ((uint16_t)0x0525)<br>#define USART_IT_IDLE ((uint16_t)0x0424)<br>#define USART_IT_LBD ((uint16_t)0x0846)<br>#define USART_IT_CTS ((uint16_t)0x096A)<br>#define USART_IT_ERR ((uint16_t)0x0060)<br>#define USART_IT_ORE ((uint16_t)0x0360)<br>#define USART_IT_NE ((uint16_t)0x0260)<br>#define USART_IT_FE ((uint16_t)0x0160)</p><h3 id="串口使能"><a href="#串口使能" class="headerlink" title="串口使能"></a>串口使能</h3><p> 串口使能是通过函数 USART_Cmd()来实现的，这个使用方法是：</p><pre><code>USART_Cmd(USART1, ENABLE); //使能串口</code></pre><h3 id="开启串口响应中断"><a href="#开启串口响应中断" class="headerlink" title="开启串口响应中断"></a>开启串口响应中断</h3><p> 有些时候当我们还需要开启串口中断，那么我们还需要使能串口中断，使能串口中断的函数是：</p><pre><code>void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT,FunctionalState NewState)</code></pre><p>这个函数的第二个入口参数是标示使能串口的类型， 也就是使能哪种中断， 因为串口的中断类型有很多种。<br>比如在接收到数据的时候（RXNE 读数据寄存器非空），我们要产生中断，那么我们开启中断的方法是：</p><pre><code>USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);//开启中断，接收到数据中断</code></pre><p>我们在发送数据结束的时候（TC， 发送完成） 要产生中断，那么方法是：</p><pre><code>USART_ITConfig(USART1， USART_IT_TC， ENABLE);</code></pre><h3 id="获取相应中断状态"><a href="#获取相应中断状态" class="headerlink" title="获取相应中断状态"></a>获取相应中断状态</h3><p> 当我们使能了某个中断的时候，当该中断发生了，就会设置状态寄存器中的某个标志位。<br>经常我们在中断处理函数中，要判断该中断是哪种中断，使用的函数是：</p><pre><code>ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)</code></pre><p>比如我们使能了串口发送完成中断，那么当中断发生了， 我们便可以在中断处理函数中调用这个函数来判断到底是否是串口发送完成中断，方法是：</p><pre><code>USART_GetITStatus(USART1, USART_IT_TC)</code></pre><p>返回值是 SET，说明是串口发送完成中断发生。</p><p>if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)<br>//如果串口接收中断返回不是RESET（0），即返回的是SET(1)，即接收中断发生</p><h3 id="卡在等待发送移位寄存器为空"><a href="#卡在等待发送移位寄存器为空" class="headerlink" title="卡在等待发送移位寄存器为空"></a>卡在等待发送移位寄存器为空</h3><p>在USART的发送端有2个寄存器，<br>一个是程序可以看到的USART_DR寄存器,<br>另一个是程序看不到的移位寄存器,对应USART数据发送有两个标志，<br>一个是TXE=发送数据寄存器空，另一个是TC=发送结束。<br>当USART_DR中的数据传送到移位寄存器后，TXE被设置，此时移位寄存器开始向TX信号线按位传输数据，但因为TDR已经变空，程序可以把下一个要发送的字节(操作USART_DR)写入TDR中，而不必等到移位寄存器中所有位发送结束，所有位发送结束时(送出停止位后)硬件会设置TC标志。　　<br>另一方面，在刚刚初始化好USART还没有发送任何数据时，也会有TXE标志，因为这时发送数据寄存器是空的！！！！！如果把TXE中断打开就会进入收发中断的！！</p><p>TXEIE和TCIE的意义很简单，TXEIE允许在TXE标志为’1’时产生中断，而TCIE允许在TC标志为’1’时产生中断。　<br>　至于什么时候使用哪个标志，需要根据你的需要自己决定。但我认为TXE允许程序有更充裕的时间填写TDR寄存器，保证发送的数据流不间断。TC可以让程序知道发送结束的确切时间，有利于程序控制外部数据流的时序。<br>先说TC。即Transmission Complete。发送一个字节后才进入中断，这里称为“发送后中断”。</p><p>关于我开了TC的中断之后他一直进入中断  我们 软件清了TC标志位<br>        if(USART_GetITStatus(USART1, USART_IT_TC) != RESET)<br>         USART_ClearITPendingBit(USART1, USART_IT_TC);<br>或者可以通过读SR 即if(USART_GetflagStatus(USART1, USART_FLAG_TC ) != RESET)<br>（草！！！！我们这么写了但是还是没有不行！！ITTC和FLAGTC一直被置位！无奈之下只能手动清了）<br>CR1那个寄存器全是中断的  if(USART_GetITStatus(USART1, USART_IT_TC) != RESET)     </p><p>但是我们想清除TC中断得读SR   或者写DR</p><p>想接受的标志位RXNE  需要读DR  在我们读取数据的时候就干过这是 就已经清0了</p><p>TC（发送完成完成完成！），当该位被置位的时候，表示 USART_DR 内的数据已经被发送完成了。如 果设置了这个位的中断，则会产生中断。该位也有两种清零方式：1）读 USART_SR，写 USART_DR。2）直接向该位写 0。 </p><p>RXNE（读数据寄存器非空），当该位被置 1 的时候，就是提示已经有数据被接收到了，并 且可以读出来了。这时候我们要做的就是尽快去读取 USART_DR，通过读 USART_DR 可以将 该位清零，也可以向该位写 0，直接清除。</p><p>今天遇到的是</p><pre><code>void Usart_SendString( USART_TypeDef * pUSARTx, char *str)  &#123;  unsigned int k=0;       do &#123;              Usart_SendByte( pUSARTx, *(str + k) );              k++;        &#125; while (*(str + k)!=&#39;\0&#39;);         /* 等待发送移位寄存器为空 */          while (USART_GetFlagStatus(pUSARTx,USART_FLAG_TC)==RESET)              &#123;          &#125; &#125;</code></pre><p>卡在等待发送移位寄存器为空，因为<br>      void USART1_IRQHandler(void)<br>      //    如果TC发送中断被触发，即发送完成<br>      if(USART_GetITStatus(USART1, USART_IT_TC) != RESET)<br>      USART_ClearITPendingBit(USART1, USART_IT_TC);<br>在这里只要发完，SR的TC置1，中断触发，我就手动清了SR相应的地方，使得TC复位。<br>于是卡在了/* 等待发送移位寄存器为空 */<br> while (USART_GetFlagStatus(pUSARTx,USART_FLAG_TC)==RESET) </p><p>所以就注释掉init的//  USART_ITConfig(USART1, USART_IT_TC, ENABLE);//开启串口发送中断<br>以及注释掉//        如果TC发送中断被触发，即发送完成<br>//       if(USART_GetITStatus(USART1, USART_IT_TC) != RESET)<br>//       USART_ClearITPendingBit(USART1, USART_IT_TC);</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stm32 </tag>
            
            <tag> uart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置windows下的vscode的opencv</title>
      <link href="/blog/2021/05/08/%E9%85%8D%E7%BD%AEwindows%E4%B8%8B%E7%9A%84vscode%E7%9A%84opencv/"/>
      <url>/blog/2021/05/08/%E9%85%8D%E7%BD%AEwindows%E4%B8%8B%E7%9A%84vscode%E7%9A%84opencv/</url>
      
        <content type="html"><![CDATA[<p>今天上课老师给的代码是win底下的opencv代码，所以给win安一下opencv</p><p>但我又不想用vs studio，所以还是vscode！</p><p>参考博客<a href="https://blog.csdn.net/zhaiax672/article/details/88971248">https://blog.csdn.net/zhaiax672/article/details/88971248</a></p><h3 id="配置MINGW"><a href="#配置MINGW" class="headerlink" title="配置MINGW"></a>配置MINGW</h3><p>我surface虽然安ruby的时候安了mingw，但是加了对应的环境变量后 gcc –version还是没反应。所以又去单独下了mingw，中途选配置的时候架构选x86架构，安在以下路径。</p><pre><code>C:\Program Files\mingw-w64\x86_64-8.1.0-posix-seh-rt_v6-rev0\mingw64\bin</code></pre><p>此电脑属性高级属性环境变量添加上面的路径。关闭终端再打开 写入gcc –version，有反应即可。</p><h3 id="配置cmake"><a href="#配置cmake" class="headerlink" title="配置cmake"></a>配置cmake</h3><p>单独下载cmake解压，配置系统环境变量路径如下</p><pre><code>C:\Users\19735\cmake-3.20.2-windows-x86_64\bin</code></pre><p>将 <code>opencv-3.4.5-vc14_vc15.exe</code> 解压</p><p>在 <code>opencv\build\x64</code> 路径下新建一个 文件夹（可自起，这里是 <code>MinGW</code> ）</p><p>运行 <code>cmake-3.9.0-rc3-win64-x64\bin\cmake-gui.exe</code></p><p><code>where is the source code:</code> 选择opencv路径的sources</p><p><code>where to build the binaries:</code> 选择opencv路径的build的x64的mingw</p><p>点configure，选择如下</p><p><img src="1.png" alt="G2"></p><p>选择 MinGW 中的 C 和 C++ 编译的exe程序</p><p>我的路径： <code>C:\Program Files\mingw-w64\x86_64-5.3.0-posix-seh-rt_v4-rev0\mingw64\bin</code></p><p>C：<code>gcc.exe</code><br>C++ : <code>g++.exe</code></p><p>设置完毕点击 <strong>Finish</strong>，耐心等待进度条读完，直到输出窗口看到 <strong>Configuring done</strong>。再次点击 <strong>Configure</strong> 等待进度条读完。之后点击<strong>Generate</strong> 等待进度条读完，出现 <strong>Generating done</strong>。</p><p>这时，可以看到 opencv\build\x64\MinGW 的文件夹下新增了好多东西。</p><p>在dos框（windows power shell 也可以）里，利用 cd 命令 切换到opencv\build\x64\MinGW，输入 minGW32-make 命令</p><h3 id="出现error-invalid-register-for-seh-savexmm"><a href="#出现error-invalid-register-for-seh-savexmm" class="headerlink" title="出现error  invalid register for .seh_savexmm"></a>出现error  invalid register for .seh_savexmm</h3><pre><code>Error 1 invalid register for .seh_savexmm</code></pre><p>打开cmake-3.9.0-rc3-win64-x64\bin\cmake-gui.exe，search：cpu_di     CPU_DISPATCH 应该使用AVX2</p><p>然后重复之前configurate  generate的操作</p><p>编译时间15：36-17.18。。。。。。。。。。。。。。</p><p>编译完成之后，输入 minGW32-make install 来完成装载。<br>  <br>最后，配置环境变量 path ： </p><pre><code>C:\Users\19735\Documents\opencv\opencv\build\x64\MinGW\bin</code></pre><h3 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h3><p>launch.json     <code>&quot;miDebuggerPath&quot;</code> 改成自己的。</p><pre><code class="json">&#123;    // Use IntelliSense to learn about possible attributes.    // Hover to view descriptions of existing attributes.    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [                &#123;            &quot;name&quot;: &quot;(gdb) Launch&quot;,            &quot;type&quot;: &quot;cppdbg&quot;,            &quot;request&quot;: &quot;launch&quot;,            &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/$&#123;fileBasenameNoExtension&#125;.o&quot;,            &quot;args&quot;: [],            &quot;stopAtEntry&quot;: false,            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,            &quot;environment&quot;: [],            &quot;externalConsole&quot;: true,            &quot;MIMode&quot;: &quot;gdb&quot;,            &quot;miDebuggerPath&quot;: &quot;C:/Program Files/mingw-w64/x86_64-8.1.0-posix-seh-rt_v6-rev0/mingw64/bin/gdb.exe&quot;,            &quot;preLaunchTask&quot;: &quot;g++&quot;,            &quot;setupCommands&quot;: [                &#123;                    &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,                    &quot;ignoreFailures&quot;: true                &#125;            ]        &#125;,    ]&#125;</code></pre><p>tasks.json    修改 “-I” 和 “-L” 的路径。   ”-l“的路径去-L底下找自己下载的版本号</p><pre><code class="json">&#123;    // See https://go.microsoft.com/fwlink/?LinkId=733558    // for the documentation about the tasks.json format    &quot;version&quot;: &quot;2.0.0&quot;,   // &quot;label&quot;: &quot;g++&quot;,    &quot;command&quot;: &quot;g++&quot;,    &quot;args&quot;: [        &quot;-g&quot;,         &quot;-std=c++11&quot;,         &quot;$&#123;file&#125;&quot;,         &quot;-o&quot;,         &quot;$&#123;fileBasenameNoExtension&#125;.o&quot;,          &quot;-I&quot;, &quot;C:\\Users\\19735\\Documents\\opencv\\opencv\\build\\include&quot;,        &quot;-I&quot;, &quot;C:\\Users\\19735\\Documents\\opencv\\opencv\\build\\include\\opencv2&quot;,        &quot;-I&quot;, &quot;C:/Users/19735/Documents/opencv/opencv/build/include/opencv2&quot;,        &quot;-I&quot;, &quot;C:\\Users\\19735\\Documents\\opencv\\opencv\\build\\include\\opencv&quot;,        &quot;-L&quot;, &quot;C:\\Users\\19735\\Documents\\opencv\\opencv\\build\\x64\\MinGW\\lib&quot;,        &quot;-l&quot;, &quot;opencv_core341&quot;,        &quot;-l&quot;, &quot;opencv_imgproc341&quot;,        &quot;-l&quot;, &quot;opencv_imgcodecs341&quot;,        &quot;-l&quot;, &quot;opencv_video341&quot;,        &quot;-l&quot;, &quot;opencv_ml341&quot;,        &quot;-l&quot;, &quot;opencv_highgui341&quot;,        &quot;-l&quot;, &quot;opencv_objdetect341&quot;,        &quot;-l&quot;, &quot;opencv_flann341&quot;,        &quot;-l&quot;, &quot;opencv_imgcodecs341&quot;,        &quot;-l&quot;, &quot;opencv_photo341&quot;,        &quot;-l&quot;, &quot;opencv_videoio341&quot;      ],// 编译命令参数    &quot;problemMatcher&quot;:&#123;        &quot;owner&quot;: &quot;cpp&quot;,        &quot;fileLocation&quot;:[            &quot;relative&quot;,            &quot;$&#123;workspaceFolder&#125;&quot;        ],        &quot;pattern&quot;:[            &#123;                &quot;regexp&quot;: &quot;^([^\\\\s].*)\\\\((\\\\d+,\\\\d+)\\\\):\\\\s*(.*)$&quot;,                &quot;file&quot;: 1,                &quot;location&quot;: 2,                &quot;message&quot;: 3            &#125;        ]    &#125;,    &quot;group&quot;: &#123;        &quot;kind&quot;: &quot;build&quot;,        &quot;isDefault&quot;: true    &#125;  &#125;</code></pre><p>新建一个c_cpp_properties.json   <code>includePath</code>的路径为自己的，<code>compilerPath</code> 同理。</p><pre><code class="json">&#123;    &quot;configurations&quot;: [        &#123;            &quot;name&quot;: &quot;win&quot;,            &quot;includePath&quot;: [                &quot;$&#123;workspaceFolder&#125;/**&quot;,                &quot;C:/Users/19735/Documents/opencv/opencv/build/include/opencv2&quot;,                &quot;C:\\Users\\19735\\Documents\\opencv\\opencv\\build\\include&quot;,                &quot;C:\\Users\\19735\\Documents\\opencv\\opencv\\build\\include\\opencv2&quot;,                &quot;C:\\Users\\19735\\Documents\\opencv\\opencv\\build\\include\\opencv&quot;                            ],            &quot;defines&quot;: [],            &quot;compilerPath&quot;: &quot;C:/Program Files/mingw-w64/x86_64-8.1.0-posix-seh-rt_v6-rev0/mingw64/bin/gdb.exe&quot;,            &quot;cStandard&quot;: &quot;c11&quot;,            &quot;cppStandard&quot;: &quot;c++17&quot;,            &quot;intelliSenseMode&quot;: &quot;clang-x64&quot;        &#125;    ],    &quot;version&quot;: 4&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> opencv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> opencv配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大统一之用vscode开发单片机的platformio(tft屏幕spi显示)</title>
      <link href="/blog/2021/05/04/%E5%A4%A7%E7%BB%9F%E4%B8%80%E4%B9%8B%E7%94%A8vscode%E5%BC%80%E5%8F%91%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84platformio/"/>
      <url>/blog/2021/05/04/%E5%A4%A7%E7%BB%9F%E4%B8%80%E4%B9%8B%E7%94%A8vscode%E5%BC%80%E5%8F%91%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84platformio/</url>
      
        <content type="html"><![CDATA[<p>这回本来打算用msp432，一开始我设备那显示无驱动，我就跑去官网找 没找到。于是为了确定这个到底能不能直接用，我去云端ccs建了个工程编译烧录了一下。</p><p>但是。。过程中好像弹出来一个ccs的程序访问请求，我允许了，能烧录，回来一看设备运转正常。感觉是那个程序的原因。 </p><p>但是我发现platformio不支持432。。。</p><p>所以这回还是tivac。做的是简单亮灯（初创工程）和tft屏幕spi显示（第三方库的问题）</p><h3 id="先上pinmap"><a href="#先上pinmap" class="headerlink" title="先上pinmap"></a>先上pinmap</h3><p><img src="2.jpg" alt="image-20210504033843670"></p><h3 id="PIO初建"><a href="#PIO初建" class="headerlink" title="PIO初建"></a>PIO初建</h3><p>platformio是vscode的插件，可以全员变成arduino的框架，基本什么板子都有，统统封装成arduino的库。</p><p>vscode拓展安装platformio。安装完之后重启vscode，点外星人图标，点PIO home，新建一个project，选好板子型号和框架，生成的位置，PIO 会自动根据选择的 Board 和 Framework 配置工程并且下载需要用到的编译工具，需要的编译依赖什么的 PIO 通通帮我们搞定，一段时间过后工程就新建完成了。比如看它给我们配的配置，</p><p><img src="3.jpg" alt="image-20210504033843670"></p><p>这里的libdeps一开始是空的，后面有用第三方库就自己安装（后面那个是我注释的）</p><p>打开 <code>src</code> 文件夹下的 <code>main.cpp</code>，比如写一个亮灯的程序</p><h3 id="先找引脚"><a href="#先找引脚" class="headerlink" title="先找引脚"></a>先找引脚</h3><p>点进arduino.h  这个是它根据我们的选型给弄得一个从tivac封装到arduino的库，点进energia.h  点进末尾的pins_energia.h就可以看到对应的引脚了。其实最好自己对着pinmap看，因为如果是和别的型号通用的话有的时候不一定对？</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="c">#include &lt;Arduino.h&gt;void setup() &#123;  // put your setup code here, to run once:  pinMode(RED_LED, OUTPUT);  pinMode(BLUE_LED, OUTPUT);&#125;void loop() &#123;  // put your main code here, to run repeatedly:  digitalWrite(RED_LED, HIGH);  digitalWrite(BLUE_LED, HIGH);  delay(1000);  digitalWrite(RED_LED, LOW);  digitalWrite(BLUE_LED, HIGH);  delay(1000);&#125;</code></pre><p><img src="4.jpg" alt="image-20210504033843670"></p><p>点这个√就可以编译啦，-&gt;就是烧录咯</p><h3 id="在加一个第三方库的时候，很有可能还需要手动在ini配置里加上其依赖的第三方库"><a href="#在加一个第三方库的时候，很有可能还需要手动在ini配置里加上其依赖的第三方库" class="headerlink" title="在加一个第三方库的时候，很有可能还需要手动在ini配置里加上其依赖的第三方库"></a>在加一个第三方库的时候，很有可能还需要手动在ini配置里加上其依赖的第三方库</h3><p>比如我现在想用TFT屏幕，就去了pio home的libraries搜tft。有个adafruit ILI9341，</p><p>就用这家的吧 adafruit做了很多库。（我是从后面回来的，其实我发现，那个adafruit ST7735的库，其实就是我手里这个tft屏幕的型号。）</p><p><img src="5.jpg" alt="image-20210504033843670"></p><p>选好版本，点add to project 就会自动添加到platformio.ini，  配置文件里只会添加这一个库</p><p><img src="6.jpg" alt="image-20210504033843670"></p><p>而libdeps会有其他四个标题添加进来，这些都是adafruit ILI9341所依赖的库。在library.properties 会写他依赖了什么。但它的依赖又会依赖别的东西，反正套娃完就是四个了</p><p><img src="7.jpg" alt="image-20210504033843670"></p><p><img src="8.jpg" alt="image-20210504033843670"></p><p>这个时候就需要我们把这其他的四个添加到ini配置里去了</p><p><img src="9.jpg" alt="image-20210504033843670"></p><p>看library.properties 这个文件里有这个第三方库的name和 version</p><p>看.piopm也可以。挨个找完补到配置里去</p><p><img src="10.jpg" alt="image-20210504033843670"></p><p>尝试编译，由于ini配置里指定了依赖，所以新加的库也都会被编译。</p><p><img src="11.jpg" alt="image-20210504033843670"></p><p><img src="12.jpg" alt="image-20210504033843670"></p><p>这个时候就有意思了，会发现，</p><h3 id="欸？怎么还找不到wire-h和spi-h？（需要手动添加tiva官方库）"><a href="#欸？怎么还找不到wire-h和spi-h？（需要手动添加tiva官方库）" class="headerlink" title="欸？怎么还找不到wire.h和spi.h？（需要手动添加tiva官方库）"></a>欸？怎么还找不到wire.h和spi.h？（需要手动添加tiva官方库）</h3><p> 这其实是tiva的官方库。</p><h3 id="来解释一下energia官方为了让我们能把tivac当成arduino开发提供了什么东西。"><a href="#来解释一下energia官方为了让我们能把tivac当成arduino开发提供了什么东西。" class="headerlink" title="来解释一下energia官方为了让我们能把tivac当成arduino开发提供了什么东西。"></a>来解释一下energia官方为了让我们能把tivac当成arduino开发提供了什么东西。</h3><p>看过energia博客的应该知道，energia是TI做的一个把自己家板子包装成arduino的framework的一个平台，比如我们在用tivac的时候需要在开发板管理器那下载对应的包装</p><p><img src="13.jpg" alt="image-20210504033843670"></p><p>这样在示例中会有core，确保tivac可以用arduino的开发方式开发。</p><p><img src="14.jpg" alt="image-20210504033843670"></p><p>把文件首选项中的显示详细输出勾上</p><p><img src="15.jpg" alt="image-20210504033843670"></p><p>跑一个内置实例blink 会看到底下说它</p><pre><code class="c">Using core &#39;tivac&#39; from platform in folder: C:\Users\19735\AppData\Local\Energia15\packages\energia\hardware\tivac\1.0.4</code></pre><p>打开相应位置 ，这里就是我们在开发板管理器那下载的对应的东西</p><p><img src="17.jpg" alt="image-20210505032903466"></p><p>core里有arduino.h energia.h ;variants里有pins_energia.h 这些就就是我们在前面新建一个不加第三方库的时候看引脚用的。  而libraries就是 实例里多的那些tivac的库  这些都是tivac官方在energia里提供给我们的。在libraries里面有SPI,有WIFI，自然也有SPI.h  WIFI.h</p><h3 id="再来看platformio里TIVAC的官方库扮演了什么角色"><a href="#再来看platformio里TIVAC的官方库扮演了什么角色" class="headerlink" title="再来看platformio里TIVAC的官方库扮演了什么角色"></a>再来看platformio里TIVAC的官方库扮演了什么角色</h3><p>也没啥，就是官方库而已，官方库和第三方库的区别. 看底下这个framework-energiativa，就是一个在板子选型的时候就已经built-in了，一个需要在registry里搜了自己安装。</p><p><img src="18.jpg" alt="image-20210505032903466"></p><p>至于官方这个库在选型初建工程的时候被放在哪了呢？还记得找引脚的时候的pin_energia吧，</p><p><img src="19.jpg" alt="image-20210505032903466"></p><p>这就是他的路径。</p><p>而就像energia里，这些库我们不选他做例程，也不会include，所以在platformio里，如果用到这些库，都是需要手动添加到ini配置里的.</p><p><img src="20.jpg" alt="image-20210505032903466"></p><p>现在库都添加完咯</p><p>开心的编译，结果发现出现一大堆错误呢，</p><h3 id="说我没定义BitOrder，（需要手动宏定义带上板子型号）"><a href="#说我没定义BitOrder，（需要手动宏定义带上板子型号）" class="headerlink" title="说我没定义BitOrder，（需要手动宏定义带上板子型号）"></a>说我没定义BitOrder，（需要手动宏定义带上板子型号）</h3><p><img src="21.jpg" alt="image-20210505032903466"></p><pre><code class="c">// some modern SPI definitions don&#39;t have BitOrder enum#if (defined(__AVR__) &amp;&amp; !defined(ARDUINO_ARCH_MEGAAVR)) ||                    \    defined(ESP8266) || defined(TEENSYDUINO) || defined(SPARK) ||              \    defined(ARDUINO_ARCH_SPRESENSE) || defined(MEGATINYCORE) ||                \    defined(DXCORE) || defined(ARDUINO_AVR_ATmega4809) ||                      \    defined(ARDUINO_AVR_ATmega4808) || defined(ARDUINO_AVR_ATmega3209) ||      \    defined(ARDUINO_AVR_ATmega3208) || defined(ARDUINO_AVR_ATmega1609) ||      \    defined(ARDUINO_AVR_ATmega1608) || defined(ARDUINO_AVR_ATmega809) ||       \    defined(ARDUINO_AVR_ATmega808)typedef enum _BitOrder &#123;  SPI_BITORDER_MSBFIRST = MSBFIRST,  SPI_BITORDER_LSBFIRST = LSBFIRST,&#125; BitOrder;#elif defined(ESP32) || defined(__ASR6501__)// some modern SPI definitions don&#39;t have BitOrder enum and have different SPI// mode definestypedef enum _BitOrder &#123;  SPI_BITORDER_MSBFIRST = SPI_MSBFIRST,  SPI_BITORDER_LSBFIRST = SPI_LSBFIRST,&#125; BitOrder;#else// Some platforms have a BitOrder enum but its named MSBFIRST/LSBFIRST#define SPI_BITORDER_MSBFIRST MSBFIRST#define SPI_BITORDER_LSBFIRST LSBFIRST#endif#if defined(__AVR__) || defined(TEENSYDUINO)typedef volatile uint8_t BusIO_PortReg;typedef uint8_t BusIO_PortMask;#define BUSIO_USE_FAST_PINIO#elif defined(ESP8266) || defined(ESP32) || defined(__SAM3X8E__) ||            \    defined(ARDUINO_ARCH_SAMD)typedef volatile uint32_t BusIO_PortReg;typedef uint32_t BusIO_PortMask;#define BUSIO_USE_FAST_PINIO#elif (defined(__arm__) || defined(ARDUINO_FEATHER52)) &amp;&amp;                      \    !defined(ARDUINO_ARCH_MBED) &amp;&amp; !defined(ARDUINO_ARCH_RP2040)typedef volatile uint32_t BusIO_PortReg;typedef uint32_t BusIO_PortMask;#if not defined(__ASR6501__)#define BUSIO_USE_FAST_PINIO#endif#else#undef BUSIO_USE_FAST_PINIO#endif/**! The class which defines how we will talk to this device over SPI **/class Adafruit_SPIDevice &#123;public:  Adafruit_SPIDevice(int8_t cspin, uint32_t freq = 1000000,                     BitOrder dataOrder = SPI_BITORDER_MSBFIRST,                     uint8_t dataMode = SPI_MODE0, SPIClass *theSPI = &amp;SPI);  Adafruit_SPIDevice(int8_t cspin, int8_t sck, int8_t miso, int8_t mosi,                     uint32_t freq = 1000000,                     BitOrder dataOrder = SPI_BITORDER_MSBFIRST,                     uint8_t dataMode = SPI_MODE0);  ~Adafruit_SPIDevice();  bool begin(void);  bool read(uint8_t *buffer, size_t len, uint8_t sendvalue = 0xFF);  bool write(uint8_t *buffer, size_t len, uint8_t *prefix_buffer = NULL,             size_t prefix_len = 0);  bool write_then_read(uint8_t *write_buffer, size_t write_len,                       uint8_t *read_buffer, size_t read_len,                       uint8_t sendvalue = 0xFF);  uint8_t transfer(uint8_t send);  void transfer(uint8_t *buffer, size_t len);  void beginTransaction(void);  void endTransaction(void);private:  SPIClass *_spi;  SPISettings *_spiSetting;  uint32_t _freq;  BitOrder _dataOrder;  uint8_t _dataMode;  int8_t _cs, _sck, _mosi, _miso;#ifdef BUSIO_USE_FAST_PINIO  BusIO_PortReg *mosiPort, *clkPort, *misoPort, *csPort;  BusIO_PortMask mosiPinMask, misoPinMask, clkPinMask, csPinMask;#endif  bool _begun;&#125;;#endif // Adafruit_SPIDevice_h</code></pre><p>看前面defined那些，只有过了defined才能给我们申明BitOrider类，然而根本没有带我们__TM4C123GH6PM__玩呢。</p><p>咱们强行硬插一下TM4C123GH6PM   这个怎么写看这个PIO的tivac工程给我们提供的energia.h</p><pre><code>#if (defined(__AVR__) &amp;&amp; !defined(ARDUINO_ARCH_MEGAAVR)) ||                    \    defined(ESP8266) || defined(TEENSYDUINO) || defined(SPARK) ||              \    defined(ARDUINO_ARCH_SPRESENSE) || defined(MEGATINYCORE) ||                \    defined(DXCORE) || defined(ARDUINO_AVR_ATmega4809) ||                      \    defined(ARDUINO_AVR_ATmega4808) || defined(ARDUINO_AVR_ATmega3209) ||      \    defined(ARDUINO_AVR_ATmega3208) || defined(ARDUINO_AVR_ATmega1609) ||      \    defined(ARDUINO_AVR_ATmega1608) || defined(ARDUINO_AVR_ATmega809) ||       \    defined(ARDUINO_AVR_ATmega808)  || defined(__TM4C123GH6PM__)typedef enum _BitOrder &#123;  SPI_BITORDER_MSBFIRST = MSBFIRST,  SPI_BITORDER_LSBFIRST = LSBFIRST,&#125; BitOrder;</code></pre><p>开心编译，结果好家伙，</p><h3 id="这回这个adafruit的库说我们没有SPISettings的函数（PIO的tiva官方库更新不够快）"><a href="#这回这个adafruit的库说我们没有SPISettings的函数（PIO的tiva官方库更新不够快）" class="headerlink" title="这回这个adafruit的库说我们没有SPISettings的函数（PIO的tiva官方库更新不够快）"></a>这回这个adafruit的库说我们没有SPISettings的函数（PIO的tiva官方库更新不够快）</h3><p>我这去它include的SPI.h查了一圈，还真没有。我就在想会不会是因为它是tivac所以没有，没有封装。于是我去新建了一个本来就是arduino工程的，它的spi.h还真有这个函数。</p><p>这个时候我福临心智，去看看energia的tiva官方给我们的spi.h里有没有把。被我这一看，还真有。。</p><p>昊佳告诉我很有可能是官方的可能更新了，plantform的没更新。</p><p>我把spi.h覆盖掉了，但是又有新的没命名的错，是pin_energia.h的不一样。。我又去替换，结果又有错。我要吐啦。</p><p>于是我把所有的tivac的都替换了。这个BUSIO_USE_FAST_PINIO定义了才会有这个函数，左边是1.5几版本的右边是1.7几版本。反正对于tivac都会把BUSIO_USE_FAST_PINIO定义，定义了就会用到port out register。</p><p><img src="22.png" alt="image-20210505032903466"></p><p><img src="23.png" alt="image-20210505032903466"></p><p>我又用g2  也没一个好使的。。。我服啦、、、、、、、、！这是什么狗屁垃圾库。</p><p>昊佳直接把BUSIO_USE_FAST_PINIO给undef了。。</p><p><img src="24.jpg" alt="image-20210505032903466"></p><p>他说反正这个是软件spi可以不用，直接用硬件spi，所以干脆注释掉…….</p><h3 id="介绍一下Adafruit的SPI相关结构"><a href="#介绍一下Adafruit的SPI相关结构" class="headerlink" title="介绍一下Adafruit的SPI相关结构"></a>介绍一下Adafruit的SPI相关结构</h3><p>BUSIO_USE_FAST_PINIO这玩意就是快速写IO口的东西，正常是慢速写IO的</p><p>来看看比赛的时候我们用的Adafruit_ST7735这个库</p><pre><code>  //ST7735 1.8TFT 128x160  #define TFT_CS        2  #define TFT_RST        9 // Or set to -1 and connect to Arduino RESET pin  #define TFT_DC         8  Adafruit_ST7735 tft = Adafruit_ST7735(TFT_CS, TFT_DC, TFT_RST);</code></pre><p>在他的Adafruit_ST7735的cpp里面</p><pre><code>// CONSTRUCTORS ************************************************************/*!    @brief  Instantiate Adafruit ST7735 driver with software SPI    @param  cs    Chip select pin #    @param  dc    Data/Command pin #    @param  mosi  SPI MOSI pin #    @param  sclk  SPI Clock pin #    @param  rst   Reset pin # (optional, pass -1 if unused)*/Adafruit_ST7735::Adafruit_ST7735(int8_t cs, int8_t dc, int8_t mosi, int8_t sclk,                                 int8_t rst)    : Adafruit_ST77xx(ST7735_TFTWIDTH_128, ST7735_TFTHEIGHT_160, cs, dc, mosi,                      sclk, rst) &#123;&#125;/*!    @brief  Instantiate Adafruit ST7735 driver with default hardware SPI    @param  cs   Chip select pin #    @param  dc   Data/Command pin #    @param  rst  Reset pin # (optional, pass -1 if unused)*/Adafruit_ST7735::Adafruit_ST7735(int8_t cs, int8_t dc, int8_t rst)    : Adafruit_ST77xx(ST7735_TFTWIDTH_128, ST7735_TFTHEIGHT_160, cs, dc, rst) &#123;&#125;#if !defined(ESP8266)/*!    @brief  Instantiate Adafruit ST7735 driver with selectable hardware SPI    @param  spiClass  Pointer to an SPI device to use (e.g. &amp;SPI1)    @param  cs        Chip select pin #    @param  dc        Data/Command pin #    @param  rst       Reset pin # (optional, pass -1 if unused)*/Adafruit_ST7735::Adafruit_ST7735(SPIClass *spiClass, int8_t cs, int8_t dc,                                 int8_t rst)    : Adafruit_ST77xx(ST7735_TFTWIDTH_128, ST7735_TFTHEIGHT_160, spiClass, cs,                      dc, rst) &#123;&#125;#endif // end !ESP8266</code></pre><p>有软件SPI 硬件SPI 可选的硬件SPI，我们调用这个库的时候就是根据传的Adafruit_ST7735 tft = Adafruit_ST7735()参数，判定用哪个函数。</p><p>就比如说这个可选的硬件SPI的函数（Adafruit_ST7735::Adafruit_ST7735(SPIClass *spiClass, int8_t cs, int8_t dc,int8_t rst)），跳转到他的引用上去看他是怎么用的。其实没有发现，但是那个Adafruit_ST7789::Adafruit_ST7789(SPIClass *spiClass, int8_t cs, int8_t dc,int8_t rst)我找到了，在这个adafruit ST7735的examples里是这样写的</p><pre><code class="c">Adafruit_ST7789 tft = Adafruit_ST7789(&amp;SPI1, TFT_CS, TFT_DC, TFT_RST);</code></pre><p>这个SPI1点进去在TIVAC官方的framework-energiativa的SPI.cpp里面这么写的</p><pre><code>#if SPI_INTERFACES_COUNT &gt; 0  SPIClass SPI0(0);#endif#if SPI_INTERFACES_COUNT &gt; 1  SPIClass SPI1(1);#endif#if SPI_INTERFACES_COUNT &gt; 2  SPIClass SPI2(2);#endif#if SPI_INTERFACES_COUNT &gt; 3  SPIClass SPI3(3);#endif</code></pre><p>而class SPIClass是这样的</p><pre><code>class SPIClass &#123;private:    uint8_t SSIModule;    uint8_t SSIBitOrder;  static uint8_t inTransactionFlag;  static uint8_t initialized;  static uint8_t interruptMode; // 0=none, 1=mask, 2=global  static uint8_t interruptMask[NUM_PORTS]; // which interrupts to mask  static uint8_t interruptSave[NUM_PORTS]; // temp storage, to restore statepublic:  SPIClass(void);  SPIClass(uint8_t);  void begin(); // Default  void end();  void usingInterrupt(uint8_t interruptNumber);  void notUsingInterrupt(uint8_t interruptNumber);  void endTransaction(void);  void beginTransaction(SPISettings settings);  void setBitOrder(uint8_t);  void setBitOrder(uint8_t, uint8_t);  void setDataMode(uint8_t);  void setClockDivider(uint8_t);  uint8_t transfer(uint8_t);  uint16_t transfer16(uint16_t data);  void transfer(void *buf, size_t count);  //Stellarpad-specific functions  void setModule(uint8_t);&#125;;</code></pre><p>这个传入的参数0123其实没什么用，就是分配了一下ID？大概说这个是第一个spi这个是第二个？，然后给我们创了相应的要开发硬件spi所需要的spiclass，就有了和其相关的函数。这样对于有多个spi的硬件，咱可以都用上，然后每个spi设置选择不同的setModule啊，用哪个中断的interruptmask啥的呀，balabalabala。</p><p>不然我们想同时用两种不同方式的spi驱动tft屏幕，但是又只有一个Adafruit_ST7735::Adafruit_ST7735(int8_t cs, int8_t dc, int8_t rst)，虽然可以再创一个Adafruit_ST7735::Adafruit_ST7735类，而且可以根据cs dc rst端口，选不同的spi，但是每一个的spi的模式都是一样的，那就挺愁的。</p><p>好啦这个介绍完了。</p><p>然后咱们再看有什么报错吧。。。</p><h3 id="（这回是arduino-C-前置声明的问题）"><a href="#（这回是arduino-C-前置声明的问题）" class="headerlink" title="（这回是arduino/C++前置声明的问题）"></a>（这回是arduino/C++前置声明的问题）</h3><p><img src="25.jpg" alt="image-20210505032903466"></p><p>我们看这个（本来我看他第二段灰了以为是板子型号的宏定义不能用，就多加了一个|| defined(<strong>TM4C123GH6PM</strong>)但是其实不是，只是我的当时把energia的tiva库删了找不到而已。）</p><p>这个是要把用到wire的地方换成wire1</p><p><img src="26.jpg" alt="image-20210505032903466"></p><p>但是wire1是后面定义的</p><p><img src="27.jpg" alt="image-20210505032903466"></p><p>我想到arduino不必把函数啊什么的提前声明，但是c++需要，所以我在前面加了一句来宏一下</p><pre><code>extern TwoWire Wire1;</code></pre><p>但是又说我TwoWire没定义，而twowire也在底下class定义了的</p><pre><code>class TwoWire : public Stream&#123;</code></pre><p>于是我再声明一下twowire就好了</p><pre><code>class TwoWire;</code></pre><p>最后是这样</p><p><img src="28.jpg" alt="image-20210505032903466"></p><h3 id="在看有什么错。。utoa。。。"><a href="#在看有什么错。。utoa。。。" class="headerlink" title="在看有什么错。。utoa。。。"></a>在看有什么错。。utoa。。。</h3><p><img src="29.jpg" alt="image-20210505032903466"></p><p>这个是真的迷</p><p><img src="30.jpg" alt="image-20210505032903466"></p><p><img src="31.jpg" alt="image-20210505032903466"></p><p>我真不明白他这个为什么自己的库wstring用到utoa了还要在自己的itoa里面把它关掉。。难道是忘了把wstring注释掉？于是我都打开了。。</p><p>我佛啦 ，终于success了呢。。虽然过程很淦呢。。。</p><h3 id="介绍一下SPI通信原理和TFT屏幕吧。"><a href="#介绍一下SPI通信原理和TFT屏幕吧。" class="headerlink" title="介绍一下SPI通信原理和TFT屏幕吧。"></a>介绍一下SPI通信原理和TFT屏幕吧。</h3><p>spi，有时钟线CLK，所以是同步的，有SIMO,SOMI可以一边收一边发所以是全双工。</p><p>一般3或4根线，第四根是STE  也就是slave transmit enable，也就是从机片选cs（chip select）  或者叫 ss（slave select）。</p><p>而TFT屏幕</p><p><img src="32.png" alt="image-20210505032903466"></p><p><img src="33.png" alt="image-20210505032903466"></p><p>SCL是clock线， </p><p>SDA是MOSI线，  </p><p>reset是复位线，</p><p>DC也叫A0也叫RS是data/command线，线上写高低电平用来说明数据是data还是指令的 </p><p>CS是片选。</p><p>这个库的函数是这样，自己选择tivac这块板子上自己想用的spi口（见文章开头的pinmap），比如我想选第二个spi，而spi2的cs的端口是2，所以就把tft_cs写端口2，这样我们连线的时候，什么时钟线啊MOSI线啊都得用spi2的对应口。</p><p>然后对于res和dc这两个端口，dc随便找个端口，不过我们找哪个口就得把TFT这个函数的dc写哪个口，rst同理。</p><pre><code>  #define TFT_CS        2  #define TFT_RST        9 // Or set to -1 and connect to Arduino RESET pin  #define TFT_DC         8  Adafruit_ST7735 tft = Adafruit_ST7735(TFT_CS, TFT_DC, TFT_RST);</code></pre><p>感觉rst这个口的作用是，在我突然拔掉其中一根线比如说rst或者dc啥的时候可以自动变成初始态全白？？再插上去也不能成为loop里设定的那样，只能重新烧录或者按总复位键，反正就是应对突发情况进行保护？（瞎说的）</p><p>好咯用spi显示tft屏幕就做完啦。配好环境加好库就好了，写代码什么的，也不必说了吧~毕竟说实话对于PIO来说，最困难的事就是搭环境啊，以前都是昊佳给搭好了，这回终于自己搭了一遍，虽然整个过程心态很崩溃但是搞完之后竟然感觉，我膨胀了起来我又行了！（然后下回又被搞的很痛苦吧哎…）</p><h3 id="gossip"><a href="#gossip" class="headerlink" title="gossip"></a>gossip</h3><p>放一下2020TI杯D题第二名国二的代码链接吧..</p><p><a href="https://github.com/huatingzhihoudahao/Trajectory-display-and-servo-tracking-of-moving-objects-based-on-millimeter-wave-radar-">https://github.com/huatingzhihoudahao/Trajectory-display-and-servo-tracking-of-moving-objects-based-on-millimeter-wave-radar-</a></p><p>两部分：一部分串口读毫米波雷达的数据，把行动的车的轨迹和车离原点的距离显示在tft屏幕上，加控制舵机随着远处车走给打角（舵机上绑个手电筒啦）。</p><p>一部分是用msp432用红外对管给车巡线，要可以设置不同的速度（加了个菜单屏幕做ui）。被手电筒照着了要让车上蜂鸣器响（拿了个光敏电阻搞adc）。好像还手写编码器测速，不过效果不好没用好像。</p><p>组委会提供了432的库函数之类的，还提供了毫米波雷达的消息解析和处理，它自己检测行动物体后就会把消息（xyz信息）按照自己的格式从串口发出去，而我们用tivac串口读毫米波雷达的消息，也不需要自己解码，这个组委会已经提供了。相当于把芯片给我们（正常用一块芯片厂家就应该这样吧？）。我感觉整个比赛挺花时间的点在于开发板是全新的，432基本没学校用过，要有很强的移植能力迅速上手，芯片也没用过，也需要处理，不过好在已经帮我们解码解完了。</p><p>反正我现在觉得我们应该会一点寄存器，其实要求会这个是因为这样才能看芯片手册，遇到bug才能对着手册调（比如那会我调stm32的串口问题？到时候再开一章写写吧，害，不过会的程度到能看数据手册就行了,这年代除了电子的人谁还用寄存器写啊，电子人自己都转stm32了）；要会库函数，可以读懂不管什么形式的封装。这样我们在想用第三方库的时候可以很方便。但是还是得熟透啊，这样才能看到BUSIO_USE_FAST_PINIO就知道这个是软件写spi，不用就直接注释。虽然我写过软件spi但是根本不记得了。</p><p>还是要养成写博客的好习惯！不写博客自己写txt文档也行啊，反正就是得存个档方便自己以后看！</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式开发环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
            <tag> platformio </tag>
            
            <tag> 全员arduino </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>energia开发环境(TIVAC)</title>
      <link href="/blog/2021/05/04/energia%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
      <url>/blog/2021/05/04/energia%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>这回用的TIVAC，直接烧录是烧录不进去的，会发现设备根本没有配置好，需要手动安装驱动，驱动去TI官网找</p><p><a href="https://www.ti.com.cn/tool/cn/STELLARIS_ICDI_DRIVERS#supp-products-hw-dl">https://www.ti.com.cn/tool/cn/STELLARIS_ICDI_DRIVERS#supp-products-hw-dl</a></p><p>先去energia官网下个pinmap</p><p><img src="2.jpg" alt="image-20210504033843670"></p><p>这回主要是讲怎么energia开发</p><p>它可以支持TI家基本所有的板子，而且不必读寄存器或者看库函数，直接arduino开发，但是没有断点，以及库其实没有那么全备，很多都是一些冷门的外设的库，（或许不是冷门只是我孤陋寡闻？）</p><p>下载energia</p><p><a href="https://energia.nu/download/">https://energia.nu/download/</a></p><p>点工具-&gt; 开发板管理器-&gt;下载想要的板子  </p><p><img src="1.jpg" alt="image-20210504033843670"></p><p>然后工具-&gt;开发板-&gt;选中自己的板子</p><p>然后文件 示例 选自己想要的模板开始开发吧  右上角是串口显示，这里没法断点调试</p><p>效果</p><p><img src="3.jpg" alt="image-20210504033843670"></p><p>energia官网有函数。<a href="https://energia.nu/reference/">https://energia.nu/reference/</a>  基本等于arduino开发，就是得对着pinmap看引脚，有的时候为了库通用，给出来的不一定能用</p><p>点文件首选项把编译和上传的详细输出开上可以看到很多详细的信息。</p><h3 id="对应多个库的问题"><a href="#对应多个库的问题" class="headerlink" title="对应多个库的问题"></a>对应多个库的问题</h3><p><img src="4.jpg" alt="image-20210504033843670"></p><p>em其实不用管的，把首选项的编译和上传的详细输出关掉就看不见了其实  &lt;-__&lt;-  其实我也没发现tivac的哪多了个wire.h。我用spi库的时候，说我有多个，我确实在不同的地方都看到有spi.h。哈反正不用管也行啦，他自己会说自己选哪个用了，能编译过就行。</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式开发环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> energia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>msp430g2之示波器(ADC UART)</title>
      <link href="/blog/2021/05/04/msp430g2%E4%B9%8B%E7%A4%BA%E6%B3%A2%E5%99%A8/"/>
      <url>/blog/2021/05/04/msp430g2%E4%B9%8B%E7%A4%BA%E6%B3%A2%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>用的RX TX   P1_1  P1_2  和串口屏RX接TX    TX 接RX       波特率115200</p><p>ADC用的是1.4通道。</p><p><img src="LaunchPadMSP430G2553.jpg" alt="G2"> </p><p>从energia官网下载的pinmaps（energia是一个高度类似arduino的编译环境，虽然不能断点调试只能串口调试，但是官网这个真的香，TI家的板子大部分都有，而且还能导入到ccs调试）。</p><h3 id="先过一遍通信原理吧"><a href="#先过一遍通信原理吧" class="headerlink" title="先过一遍通信原理吧"></a>先过一遍通信原理吧</h3><h4 id="并行串行"><a href="#并行串行" class="headerlink" title="并行串行"></a>并行串行</h4><p>并行通讯：同一时刻，可以传输多个bit位的信号，有多少个信号位就需要多少根信号线。</p><p>串行通讯：同一时刻，只能传输一个bit位的信号，只需要一根信号线。</p><h4 id="同步异步"><a href="#同步异步" class="headerlink" title="同步异步"></a>同步异步</h4><p>异步通信，是指通信双方按照事前约定好的时钟速率（波特率）来进行通信，因为没有公共的时钟线，所以通信双方的数据必须“整齐划一”。比如uart就是异步通信。而IIC  SPI都需要时钟线 是同步通信。而stm32的usart则是通用同步和异步收发器，可以主动提供时钟，既可以当uart用也可以当spi用</p><p>而同步通信的双方拥有公共时钟，按时钟信号来更新数据，所以数据流不一定要“整齐划一”。比如IIC SPI</p><h4 id="单工双工"><a href="#单工双工" class="headerlink" title="单工双工"></a>单工双工</h4><p>同时收发就是全双工，比如打电话。</p><p>数据能收能发，但要分时进行就是半双工，比如对讲机。</p><p>只能单向通信就是单工了，比如广播。</p><h3 id="UART特性"><a href="#UART特性" class="headerlink" title="UART特性"></a>UART特性</h3><p>uart属于串行，异步（无需时钟线），全双工（加上它是串行，所以有两条数据线，一个TX 一个RX）</p><p><img src="%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.jpg" alt="G2"> </p><p><img src="uart%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE.jpg" alt="G2"> </p><p>我们写的是八位的数据位</p><p><img src="UARTbuf.jpg" alt="G2"> </p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="c">#include &lt;msp430.h&gt;     int i=0;    int x=0;    //double p=0;    float volt=0;    int trans=0;    short temp[180]=&#123;&#125;;    short compare[6]=&#123;&#125;;    float y=0;void UART_INIT()         //初始化UART端口&#123;      P1SEL |= BIT1 + BIT2 ;                    // P1.1 = RXD, P1.2=TXD      P1SEL2 |= BIT1 + BIT2 ;                   // P1.1 = RXD, P1.2=TXD     UCA0CTL1 |= UCSSEL_2;                     // 选择SMCLK(1MHz)作为时钟源      UCA0BR0 = 139;                              // 8MHz 115200      UCA0BR1 = 0;                              // 8MHz 115200      UCA0MCTL = UCBRS2 + UCBRS0;               // Modulation UCBRSx = 5      UCA0CTL1 &amp;= ~UCSWRST;                     // USCI 软件复位      IE2 |= UCA0RXIE;                          // 使能USCI_A0 RX中断&#125;void SendString(char *s)     //UART发送字符串&#123;    while(*s!=&#39;\0&#39;)    &#123;        UCA0TXBUF = *(s++);        __delay_cycles(1500);    &#125;&#125;void ClearScreen()&#123;    __delay_cycles(1000);    SendString(&quot;CLS(0);\x0d\x0a&quot;);         //Caution:\x0d\x0a    __delay_cycles(1000);&#125;void line(int x,int y,int z)//z是上一个点的纵坐标&#123;    //    PL(x-1,z,x,y,1)    //        0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15   16  17  18  19    char l[]=&#123;&#39;P&#39;,&#39;L&#39;,&#39;(&#39;,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;,&#39;,&#39;z&#39;,&#39;z&#39;,&#39;z&#39;,&#39;,&#39;,&#39;x&#39;,&#39;x&#39;,&#39;x&#39;,&#39;,&#39;,&#39;y&#39;,&#39;y&#39;,&#39;y&#39;,&#39;,&#39;,&#39;1&#39;,&#39;)&#39;,&#39;;&#39;,&#39;\x0d&#39;,&#39;\x0a&#39;,&#39;\0&#39;&#125;;    l[3]=(x-1)/100+48;    l[4]=((x-1)%100)/10+48;    l[5]=(x-1)%10+48;    l[7]=z/100+48;    l[8]=(z%100)/10+48;    l[9]=z%10+48;    l[11]=x/100+48;    l[12]=(x%100)/10+48;    l[13]=x%10+48;    l[15]=y/100+48;    l[16]=(y%100)/10+48;    l[17]=y%10+48;       SendString(l);    __delay_cycles(1000);&#125;void free(int x)&#123;//            0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15    char l[]=&#123;&#39;P&#39;,&#39;L&#39;,&#39;(&#39;,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;,&#39;,&#39;0&#39;,&#39;,&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;,&#39;,&#39;2&#39;,&#39;2&#39;,&#39;0&#39;,&#39;,&#39;,&#39;0&#39;,&#39;)&#39;,&#39;;&#39;,&#39;\x0d&#39;,&#39;\x0a&#39;,&#39;\0&#39;&#125;;//BOXF(x-1,0,x+2,239,0)//    PL(X,0,X,220,0)    l[3]=x/100+48;    l[4]=(x%100)/10+48;    l[5]=x%10+48;    l[9]=x/100+48;    l[10]=(x%100)/10+48;    l[11]=x%10+48;       SendString(l);    __delay_cycles(1000);&#125;void Sendpoint(int x,int y)&#123;       char B[]=&#123;&#39;P&#39;,&#39;S&#39;,&#39;(&#39;,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;,&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;,&#39;,&#39;1&#39;,&#39;)&#39;,&#39;;&#39;,&#39;\x0d&#39;,&#39;\x0a&#39;,&#39;\0&#39;&#125;; B[3]=x/100+48; B[4]=(x%100)/10+48; B[5]=x%10+48; B[7]=y/100+48; B[8]=(y%100)/10+48; B[9]=y%10+48;       SendString(B); //   __delay_cycles(1000);&#125;/*初始化屏幕显示函数,返回主界面时调用*/void ScreenInit(int x,int y,int trans)&#123;   char c[]=&#123;&#39;D&#39;,&#39;S&#39;,&#39;1&#39;,&#39;6&#39;,&#39;(&#39;,&#39;2&#39;,&#39;4&#39;,&#39;0&#39;,&#39;,&#39;,&#39;5&#39;,&#39;0&#39;,&#39;,&#39;,&#39;\&#39;&#39;,&#39;a&#39;,&#39;.&#39;,&#39;c&#39;,&#39;d&#39;,&#39;V&#39;,&#39;\&#39;&#39;,&#39;,&#39;,&#39;1&#39;,&#39;)&#39;,&#39;;&#39;,&#39;\x0d&#39;,&#39;\x0a&#39;,&#39;\0&#39;&#125;;//前面发的是2 4 0 的asc   c[13]=trans/100+48;   c[15]=(trans%100)/10+48;   c[16]=trans%10+48;  SendString(c);  Sendpoint(x,y);&#125; int j;  int z=0;int main()&#123;    WDTCTL = WDTPW | WDTHOLD;   // stop watchdog timer    BCSCTL1 = CALBC1_16MHZ;    DCOCTL = CALDCO_16MHZ;     UART_INIT();     __delay_cycles(1000);     ClearScreen();     SendString(&quot;PL(5,5,5,239,1);\x0d\x0a&quot;);     SendString(&quot;PL(0,230,319,230,1);\x0d\x0a&quot;);      SendString(&quot;DS12(290,210,&#39;t&#39;,1);\x0d\x0a&quot;);     SendString(&quot;DS12(9,5,&#39;u&#39;,1);\x0d\x0a&quot;);        //  SendString(&quot;TPN(2);\x0d\x0a&quot;);//发回区域编码        //  SendString(&quot;BTN(2,250,155,318,200,1);\x0d\x0a&quot;);//跑飞        //  SendString(&quot;DS48(253,175,&#39;跑飞&#39;,1,0);\x0d\x0a&quot;);        //  SendString(&quot;BTN(1,250,100,318,145,3,0);\x0d\x0a&quot;);//正常        //  SendString(&quot;DS48(253,115,&#39;正常&#39;,1,0);\x0d\x0a&quot;);        // _EINT();    //开总中断   ADC10CTL0 &amp;= ~ENC;//配置前先关   //ADC10CTL0 =ADC10ON + ADC10IE; // ADC10ON, interrupt enabled   ADC10CTL0 =ADC10SHT_3+ADC10ON + ADC10IE;//ADC的中断开      //这里sref值默认0，基准电压是VCC3.3和GND,四个时钟周期，   ADC10CTL1 = INCH_4+ADC10SSEL_3; // input A4,接1.4,SMCLK子时钟//采样周期0.00000025s,示波器10khz  0.0001s，采180个点，两次之间0.000000555s,所以要0.000000145s中断//单通道单次采样      ADC10AE0 |= BIT4;          // PA.4 ADC option select    while(1) &#123;        // ADC10CTL0 |= ENC + ADC10SC;             // 打开ADC         while(1)      &#123;      //采5个点             for(j=0;j&lt;=4;j++)          &#123;                 ADC10CTL0 |= ENC + ADC10SC;             compare[j]=ADC10MEM;                __delay_cycles(100);//采样还是比较快的，           // 打开ADC          &#125;          if ((compare[2]&gt;compare[3])&amp;&amp;(compare[2]&gt;compare[4])&amp;&amp;(compare[2]&gt;compare[1])&amp;&amp;(compare[2]&gt;compare[0]))         &#123;               break;         &#125;     &#125;   //采集180个点         for(i=0;i&lt;180;i++)     &#123;             ADC10CTL0 |= ENC + ADC10SC;             // 打开ADC             __delay_cycles(100);             temp[i]=ADC10MEM;//乘法计算花时间，直接赋值，不要在这个for里面算*10     &#125;   //把180个点打出去    for(i=0;i&lt;180;i++)    &#123;        if(x&lt;180)       &#123;        y=239-(temp[i]*10/1024.0)*23.9;        if((i-1)&gt;=0&amp;&amp;(x-1)&gt;=0)        &#123;            z=239-(temp[i-1]*10/1024.0)*23.9;        line(x,y,z);        &#125;         volt=((temp[i]*10/1024.0))*3.3;        trans=volt*10;         __delay_cycles(1000);         free(x);         SendString(&quot;PL(5,5,5,239,1);\x0d\x0a&quot;);          SendString(&quot;DS12(9,5,&#39;u&#39;,1);\x0d\x0a&quot;);            SendString(&quot;PL(0,230,319,230,1);\x0d\x0a&quot;);         SendString(&quot;DS12(290,210,&#39;t&#39;,1);\x0d\x0a&quot;);        //  SendString(&quot;TPN(2);\x0d\x0a&quot;);//发回区域编码        //  SendString(&quot;BTN(2,250,155,318,200,1);\x0d\x0a&quot;);//跑飞        //  SendString(&quot;DS48(253,175,&#39;跑飞&#39;,1,0);\x0d\x0a&quot;);        //  SendString(&quot;BTN(1,250,100,318,145,3,0);\x0d\x0a&quot;);//正常        //  SendString(&quot;DS48(253,115,&#39;正常&#39;,1,0);\x0d\x0a&quot;);        ScreenInit(x,y,trans);        x++;       __delay_cycles(1000);       &#125;        else   x=0;    &#125;  //    __enable_interrupt();&#125;&#125;#pragma vector=USCIAB0RX_VECTOR__interrupt void USCI0RX_ISR(void)&#123;    unsigned char rxbuff = UCA0RXBUF;         // 读取RXBUF    IFG2&amp;=~UCA0RXIFG;//     if(rxbuff == &#39;1&#39;) //正常//         &#123;ClearScreen();&#125;// //    &#123;    SendString(&quot;DS48(50,50,&#39;正常&#39;,1,0);\x0d\x0a&quot;);// //    __delay_cycles(50000);&#125;//     if(rxbuff == &#39;2&#39;)//跑飞//     &#123;  SendString(&quot;DS48(50,50,&#39;跑飞&#39;,1,0);\x0d\x0a&quot;);//     __delay_cycles(50000);&#125;&#125;#pragma vector=ADC10_VECTOR__interrupt void ADC10_ISR(void)&#123;    //static double p=0;    //     p++;&#125;</code></pre><p><img src="%E6%95%88%E6%9E%9C.jpg" alt="G2"> </p><p>这里的按钮热区都被我注释掉了，原因是没有解析[BN:X]       大概得用这种方式解析一下？</p><pre><code class="c">#pragma vector=USCI_A0_VECTOR//2553是AB0_TX有一个，AB0_RX有一个中断向量，可能本来AB是共用的，但好像2553是没用B，嗷，我也不知道//反正现在5529是TX RX共用一中断向量，要查表看响应的哪个__interrupt void USCIA0_ISR(void)&#123;   static unsigned char rxbuff=123;   static unsigned int number;    switch(__even_in_range(UCA0IV,4))      &#123;      case 0:  break;                             // Vector 0 - no interrupt      case 2:            rxbuff = UCA0RXBUF;         // 读取RXBUF            UCA0IFG&amp;=~UCRXIFG;            if(rxbuff == &#39;[&#39;)            &#123;   iscmd=1;                number=0;            &#125;            else if(rxbuff == &#39;]&#39;)            &#123;  iscmd=0;               iscmdok=1;            &#125;            else if(iscmd==1)                       &#123;  cmd[number]=rxbuff;                         number++;                       &#125;          break;                                 // Vector 2 - RXIFG      case 4:    break;                             // Vector 4 - TXIFG      default: break;      &#125;&#125;</code></pre><p>写UI应结合gpumaker和状态机一起用</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> msp430g2 </tag>
            
            <tag> uart通信 </tag>
            
            <tag> ADC </tag>
            
            <tag> UsartGPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云端ccs路径配置问题</title>
      <link href="/blog/2021/05/03/%E4%BA%91%E7%AB%AFccs%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/"/>
      <url>/blog/2021/05/03/%E4%BA%91%E7%AB%AFccs%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>云端ccs很方便，直接百度ccs，进去选云端开发就行，虽然不用下CCS会引导下载点和本机串口交互的东西？带有很多库，很爽。想看官方例程直接TI官网随便搜一个搜型号，点进器材贩卖页面， 下面相关的会有430WARE套件可以下。430家所有的都有。开发的时候官网搜data sheet和user guide。</p><p>今天被云端ccs小小的坑了一下。</p><p>云端ccs在建立工程的时候可以选择很多库，比如我选的这个就带有很多adc cpu gpio巴拉巴拉的库，但是报错说打不开这个IEC60730_march_test.h   </p><p><img src="1.jpg" alt="G2"></p><p>正常情况下 工程右键 project properties link的地方选择路径，把.h给include就行。但是ccs没法改。。</p><p>所以只能自己把</p><pre><code>#include &quot;IEC60730_march_test.h&quot;</code></pre><p>改成以工程文件名为根目录   之后的绝对路径  </p><pre><code>#include &quot;IEC60730/include/IEC60730_march_test.h&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 嵌入式开发环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ccs cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>msp430g2之频率计(Timer_A)</title>
      <link href="/blog/2021/05/03/msp430g2%E9%A2%91%E7%8E%87%E8%AE%A1/"/>
      <url>/blog/2021/05/03/msp430g2%E9%A2%91%E7%8E%87%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>可以测频率和脉宽，用的Timer_A的捕获模式</p><p>先上pinmap</p><p>g2553有两个的timer_A模块，每一个包括1个16位定时器和3个捕获比较模块（CCRX）。（网上误人子弟把g2通用手册的timerA和timerB截图放上去说2553有timerA和timerB，不要信。要看看底下这个官网的datesheet里的图，而不是看通用的那种用户手册）</p><p><img src="%E6%A8%A1%E5%9D%97.jpg" alt="image-20210503144441840"></p><p><img src="pinmap.jpg" alt="image-20210503144441840"></p><p><img src="image-20210503155430023.png" alt="image-20210503155430023"></p><p>g2553的timer_A模块包括1个16位定时器和3个捕获比较模块（CCRX），定时器就搁那计数就完了，计数值被存放在TAR寄存器。配置就这个</p><p><img src="1.jpg" alt="image-20210503144441840"></p><p> 那边CCRx比较捕获模块，CCR0，CCR1，CCR2性质基本一样，</p><p>在比较的时候用TAR与TACCRx对比，计数到对比一致时对应的CCIFG置位。</p><p>在捕获的时候把TAR存入TACCRx，把对应的CCIFG置位。</p><p>不能同时捕获和比较。配置就这个</p><p><img src="2.jpg" alt="image-20210503174039643"></p><p> TAR与TACCRx就是放数字的16位寄存器</p><p>但是：CCR0是特殊的。 特殊在于：TACCR0 CCIFG 有自己单独的中断向量TACCR0  而且优先级最高。</p><p>而其他的CCIFG(指的是比较捕获模块CCR1 CCR2)和  TAIFG（溢出中断）都用一个中断向量TAIV。想分别是哪个CCIFG还是说TAIFG触发的这个中断，还需要查TAIV(寄存器用户指南371页)，像IO中断那样 （由于有两个定时器所以查的时候是TA0IV这样）</p><p>为什么搞特殊 ，因为CCR0就是用来控制timerA的定时器模块的周期的。</p><p>也就是说整个timerA两大部分，一边是定时器模块一边是比较捕获模块，</p><p>在上数模式下CCR0可以确定定时器模块的周期从0-2000增计数，那就会0-2000，然后0-2000雷打不动的计（虽然最高的65535但是CCR0定了就确定他到CCR0设置的那个点了就会按照设定的增/减/增减模式 走）    </p><p>而CCR1 和CCR2 只是说自己利用这个计数器，到了什么点，比如比较模式就比较计数器记的数有没有到自己要求的那个TACCR1值，到了就自己找个小旗子记一下（即CCIFG1置位。）  </p><p>溢出中断就是定时器模块的溢出中断的，依赖于定时器模块最后的模式。</p><p>就是比如在上数模式下从TACCR0的2000满了，重新到0，这就记一个溢出中断TAIFG</p><p>在连续模式下，计数到65535就溢出，重新到0，这也记一个溢出中断TAIFG。</p><p>比较模式一般用于输出，就计数计到多少翻转电平之类的，用于输出PWM.输出的方式啥的看比较捕获控制寄存器的outmode  （看寄存器手册362页）</p><p>捕获模式捕获的哪一个端口的看CCIS选的是CCIxA还是CCIxB</p><p><img src="3.jpg" alt="image-20210503174039643"></p><p>哪个端口是CCIxA还是CCIxB  看寄存器用户手册会让我们看data sheet 。反正就 要看哪个脚复用成哪个功能就看数据手册，寄存器就看用户手册。不会写代码就看指导书或者官网。</p><p>可以看到TA0 的CCI0A在P1.1    CCI1A在P1.2  其他的看data sheet把 今天就用这个CCR1比较捕获模块的A口，即P1.2。想复用的话，P1SEL的BIT2要置1，P1SEL2的不能置1.</p><p>总结一遍：G2553有两个定时器即为timer0_A和timer1_A，每一个由一个定时器模块(溢出中断TAIFG)   和  三个比较捕获模块(CCR0，CCR1，CCR2组成，其中CCR0在非连续模式下用来设置定时器模块的周期)。</p><p>板载资源用了timer0的CCR1的CCI1A   即TA0.1的 A口    P1.2</p><p>下面这个代码是65535默认周期，CCR1捕获，连续计数上升沿捕获。方法图如下</p><p><img src="%E5%9B%BE.jpg" alt="G2">  </p><pre><code class="c">#include &lt;msp430.h&gt; unsigned int temp1=0,temp2=0,temp3=0,temp4=0;time1=0,time2=0,time3=0,time4=0;unsigned int cap_flag=0;int overflow=0;long hz=0,maikuan=0;int main(void)&#123;    WDTCTL = WDTPW | WDTHOLD;    // Stop watchdog timer    BCSCTL1 = CALBC1_16MHZ;    DCOCTL = CALDCO_16MHZ;    //P1.2           通用型数字 I/O 引脚    //TA0.1            Timer0_A，捕捉：CCI1A 输入，比较：Out1 输出  P1SEL|=BIT2;//1.2开第二功能，没有动P1SEL2，P1SEL2也置1那就复用成uart模式了  P1DIR&amp;=~BIT2;//1.2设为读  TA0CTL|=TASSEL_2+MC_2+ TACLR+TAIE;  //smclk 16Mhz,不分频,连续计数,置位，开溢出中断  TA0CCTL1|=CM_1+CCIE+CAP+CCIS_0;//上升沿捕获，捕获使能  _EINT();  while(1);&#125;#pragma vector=TIMER0_A1_VECTOR//  响应CCR1的CCIFG CCR2的CCIFG 和溢出中断TAIFG__interrupt void Timer0_A1(void)&#123;     switch( TA0IV ) //查TAIV看是哪个中断响应    &#123; case 2:              cap_flag++; //CCR1的CCIFG              if(cap_flag==1)//第一次检测的是上升沿              &#123; overflow=0;                TA0CCTL1&amp;=~CM_1;                TA0CCTL1|=CM_2;//改成下降沿捕获                TA0CTL|= TACLR; //清定时器              &#125;              if(cap_flag==2)//这次捕获的是下降沿              &#123;  temp1=TA0CCR1;                 time1=overflow;                 TA0CCTL1&amp;=~CM_2;                 TA0CCTL1|=CM_1;//改成上升沿捕获              &#125;              if(cap_flag==3)//这次是上升沿捕获              &#123;                temp2=TA0CCR1;                time2=overflow;                hz=16000000/(time2*65536+temp2); //第二次计数的ccr1会经过可能一些周期，所以记得overflow*65536                maikuan=((time1*65536+temp1)*100)/(time2*65536+temp2);                cap_flag=0;              &#125;              break;     case 4:              break;     case 10: overflow++;//溢出中断的TAIFG,溢出一次加1          break;     &#125;&#125;//这里遇到了一个问题，就是配置CCTL|=CM_1之后，想要改为CM_2,要先&amp;=~CM_1，再|=CM_2//不然先|=CM_1,和010000……或    再|=CM_2,和10000……或，合起来就是11000……，也就是配置成了CM_3上下沿都捕获</code></pre><p>效果如图，输入是占空比30%，频率900hz的矩形波</p><p><img src="%E6%95%88%E6%9E%9C.jpg" alt="G2"></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ccs </tag>
            
            <tag> msp430g2 </tag>
            
            <tag> Timer_A中断 </tag>
            
            <tag> 捕获 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>msp430g2之IO和其外部中断(GPIO  IO外部中断)</title>
      <link href="/blog/2021/05/03/msp430g2%E4%B9%8BIO%E5%92%8C%E5%85%B6IO%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/"/>
      <url>/blog/2021/05/03/msp430g2%E4%B9%8BIO%E5%92%8C%E5%85%B6IO%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<p>本次开发用云端ccs开发，结合launchpad指导手册（教程）和g2用户手册（看寄存器）食用</p><p>板载资源就用了一个灯P1_0的red_led，时钟源全部默认</p><p><img src="LaunchPadMSP430G2553.jpg" alt="G2"></p><h2 id="msp家的所有例程上ti官网找mspware-https-dev-ti-com-tirex-explore-啥都有-直接云端开发就行。"><a href="#msp家的所有例程上ti官网找mspware-https-dev-ti-com-tirex-explore-啥都有-直接云端开发就行。" class="headerlink" title="msp家的所有例程上ti官网找mspware   https://dev.ti.com/tirex/explore/    啥都有   直接云端开发就行。"></a>msp家的所有例程上ti官网找mspware   <a href="https://dev.ti.com/tirex/explore/">https://dev.ti.com/tirex/explore/</a>    啥都有   直接云端开发就行。</h2><h3 id="先从点亮一个led灯开始吧。。。"><a href="#先从点亮一个led灯开始吧。。。" class="headerlink" title="先从点亮一个led灯开始吧。。。"></a>先从点亮一个led灯开始吧。。。</h3><p>读写IO都需要设置PxDIR 高电平输出（往外写）   低电平输入（往内读）</p><p>CPU读IO，实际上是读PxIN寄存器。</p><p>CPU写IO，实际是写PxOUT寄存器。</p><p>g2寄存器一般是八位，平时要么用十六进制表示八位  0x01  每位自己设</p><p>要么用P1DIR |= BIT0;   BIT0是00000001，|=是按位或，有1则1，这些的话最后一位会被置1 其他不变。</p><p>提示：作为高阻输入IO时，务必关掉内部上下拉电阻开关PxREN，否则输入就不是高阻态了。（悬空就是高阻态，至于为什么要上下拉我也不知道了，建议看指导手册IO结构图）</p><pre><code class="C">#include &lt;msp430.h&gt;int main(void)&#123;    volatile unsigned int i;                  //volatile是一个特征修饰符（type specifier）.volatile的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值。    WDTCTL = WDTPW + WDTHOLD;                 // Stop watchdog timer    P1DIR |= 0x01;                            // Set P1.0 to output direction  看引脚图可以看到是1_0是红灯    while(1)    &#123;        P1OUT ^= 0x01;                        // Toggle P1.0 using exclusive-OR     和00000001异或      //  P1OUT =~P1OUT;   //位操作取反        for (i=10000; i&gt;0; i--);  &#125;&#125;</code></pre><h3 id="然后做IO外部中断"><a href="#然后做IO外部中断" class="headerlink" title="然后做IO外部中断"></a>然后做IO外部中断</h3><p>用的是P1_3 push2 的外部中断</p><p><img src="LaunchPadMSP430G2553.jpg" alt="G2"></p><p><img src="1.jpg" alt="G2"></p><p><img src="2.png" alt="G2"></p><p><img src="3.jpg" alt="G2"></p><p>g2有P1P2两列外部IO中断,需要用PXIE对IO中断使能，IES设置上下边沿触发，REN设置上拉下拉</p><p>&amp;= ~是置0，进入中断之后，中断标志位会自动置1，需要PXIFG=0手动清成0.（有的会做成硬件清0，但是如果懒得查它到底自动不自动，还是直接软件清零吧）</p><p>中断向量是vector=PORT1_VECTOR    </p><pre><code class="c">#include &lt;msp430.h&gt;int main(void)&#123;  WDTCTL = WDTPW + WDTHOLD;                 // Stop watchdog timer  P1DIR |= BIT0;                            // Set P1.0 to output direction  P1IE |=  BIT3;                            // P1.3 interrupt enabled  P1IES |= BIT3;                            // P1.3 Hi/lo edge  P1REN |= BIT3;                            // Enable Pull Up on SW2 (P1.3)  P1IFG &amp;= ~BIT3;                           // P1.3 IFG cleared                                                            //BIT3 on Port 1 can be used as Switch2                                              __bis_SR_register(LPM4_bits + GIE);       // Enter LPM4 w/interrupt  //把SR寄存器的GIE位置位，也可以用_enable_interrupts();  即总中断使能   //LPM4是low power node4 直接进入低功耗模式，会被中断唤醒然后接着睡&#125;/*// Port 1 interrupt service routine#if defined(__TI_COMPILER_VERSION__) || defined(__IAR_SYSTEMS_ICC__)#pragma vector=PORT1_VECTOR//这个是给中断向量表进行赋值的__interrupt void Port_1(void)//关键字__interrupt则表示这个函数是中断服务函数这种特殊函数。#elif defined(__GNUC__) //这玩意是gcc主版本号，安装gcc了都能过预编译void __attribute__ ((interrupt(PORT1_VECTOR))) Port_1 (void)//GNU C 的一大特色就是__attribute__ 机制。attribute 可以设置函数属性（Function Attribute）、变量属性（Variable Attribute）和类型属性（Type Attribute）。这里是设置Port_1函数为PORT1_VECTOR的中断向量#else#error Compiler not supported!#endif&#123;  P1OUT ^= BIT0;                            // P1.0 = toggle  P1IFG &amp;= ~BIT3;                           // P1.3 IFG cleared&#125;*///其实大家可以不用这么写,这么写就行。#pragma vector=PORT1_VECTOR__interrupt void Port_1(void)&#123;  P1OUT ^= BIT0;                            // P1.0 = toggle  P1IFG &amp;= ~BIT3;                           // P1.3 IFG cleared&#125;</code></pre><p><img src="4.jpg" alt="G2"></p><p>P1八个IO共用这一个中断，如果想要辨别是哪个端口出的低电平，就用IFG来判断，IFG进入中断就硬件置1了。</p><p>用((P1IN&amp;Push_Key)==0)    来确保此刻是按下的，即P1那个导致进入中断的端口还处于低电平还没有恢复原状。</p><pre><code class="c">voidP1_IODect()&#123;unsigned int Push_Key=0;Push_Key=P1IFG&amp;(~P1DIR);//代码1：检测所有输入IO，确保只有1个IO中断被“记录”//----延时一段时间，避开机械抖动区域------__delay_cycles(10000);//代码2：消灭下降沿2、3、5//----判断按键状态是否与延时前一致------if((P1IN&amp;Push_Key)==0) //代码3：专门消灭下降沿4&#123;//----判断具体哪个IO被按下，调用该IO的事件处理函数    switch(Push_Key)//代码4：不用P1IN来判断，以确保有且只有1按键响应    &#123;        case BIT0: P10_Onclick();break;        case BIT1: P11_Onclick();break;        case BIT2: P12_Onclick();break;        case BIT3: P13_Onclick();break;        case BIT4: P14_Onclick();break;        case BIT5: P15_Onclick();break;        case BIT6: P16_Onclick();break;        case BIT7: P17_Onclick();break;        default:break;    &#125;&#125;</code></pre><p>P1x_Onclick()自己定义。</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ccs </tag>
            
            <tag> IO外部中断 </tag>
            
            <tag> msp430g2 </tag>
            
            <tag> GPIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>鉴于我的bug体质这里可能有你需要的大部分hexo主题相关解决方案</title>
      <link href="/blog/2021/04/30/bug%20in%20first%20blog/"/>
      <url>/blog/2021/04/30/bug%20in%20first%20blog/</url>
      
        <content type="html"><![CDATA[<p>BUG</p><h2 id="tips-改完得hexo-clean-g-d-来一趟上传上去（如果搞完了还是没好，可能是网太烂，换一个网8）-如果改了module的js之类的，务必要clean！！！"><a href="#tips-改完得hexo-clean-g-d-来一趟上传上去（如果搞完了还是没好，可能是网太烂，换一个网8）-如果改了module的js之类的，务必要clean！！！" class="headerlink" title="tips.改完得hexo clean g d 来一趟上传上去（如果搞完了还是没好，可能是网太烂，换一个网8）    如果改了module的js之类的，务必要clean！！！"></a><em>tips.改完得hexo clean g d 来一趟上传上去（如果搞完了还是没好，可能是网太烂，换一个网8）    如果改了module的js之类的，务必要clean！！！</em></h2><h2 id="1-本地显示正常，上传的网站css渲染不出来or一片空白"><a href="#1-本地显示正常，上传的网站css渲染不出来or一片空白" class="headerlink" title="1.本地显示正常，上传的网站css渲染不出来or一片空白"></a>1.本地显示正常，上传的网站css渲染不出来or一片空白</h2><p>改_config,     url: https://用户名.github.io/rep名    root:/rep名/    </p><pre><code>url: https://huatingzhihoudahao.github.io/blog/root: /blog/</code></pre><p>然后自己的网站名就成了<a href="https://huatingzhihoudahao.github.io/blog/">https://huatingzhihoudahao.github.io/blog/</a></p><p>我是从后面9来的，插图片更换插件代码，没能成功，改了url为<a href="https://huatingzhihoudahao.github.io才成功../">https://huatingzhihoudahao.github.io才成功。。</a></p><h2 id="2-文件在上传的网站上无显示"><a href="#2-文件在上传的网站上无显示" class="headerlink" title="2.文件在上传的网站上无显示"></a>2.文件在上传的网站上无显示</h2><p>注意的deploy的branch和github pages的是否一致，一开始我用的master，github的仓库里倒是有了，但是网站显示的是gh。</p><pre><code>branch: gh-pages</code></pre><p>以及注意主题选的啥玩意。。。（我选的是github pages推的merlot，是个 jekyll 的主题。。根本不是hexo的，由于那个主题实在是好看我又跑去搭jekyll，结果有个什么玩意又要0.3.6的又要0.4.0的没整好，不了了之。。换回hexo了，hexo还是简单点…）</p><h2 id="3-换主题之后上传的网站一片空白"><a href="#3-换主题之后上传的网站一片空白" class="headerlink" title="3.换主题之后上传的网站一片空白"></a>3.换主题之后上传的网站一片空白</h2><p>看自己主题的作者的md，以及issue (我下的是据作者说有lofter那味儿的snark，有个搜索功能，需要自己在yml里添加一下)</p><pre><code>search:    path: search.xml    field: post</code></pre><h2 id="4-上传网站主题的头像是本地图片，然而显示不出来"><a href="#4-上传网站主题的头像是本地图片，然而显示不出来" class="headerlink" title="4.上传网站主题的头像是本地图片，然而显示不出来"></a>4.上传网站主题的头像是本地图片，然而显示不出来</h2><p>这招是乐哥教的，按住fn 和f12，查看源码，点左上角第一个的框框，即选中一个元素进行检查，然后点到没出来的图片上，可以看到对应的代码位置。我的是这个</p><pre><code>&lt;img class=&quot;nofancybox&quot; src=&quot;/img/profile.jpg&quot; width=&quot;128&quot; height=&quot;128&quot;&gt;</code></pre><p>把斜杠去掉，（本地好像是得加一个空格）   </p><pre><code>&lt;img class=&quot;nofancybox&quot; src=&quot;img/profile.jpg&quot; width=&quot;128&quot; height=&quot;128&quot;&gt;</code></pre><p>不过这些改了没用，只是当前页面有用，再打开一回还是原来那样，所以去改主题源码吧，一般在主题的layout 的_partial底下，挺多的，抽奖找文件吧？我的是在nav-menu，斜杠删了就行</p><pre><code>        a(class=&quot;hdimg img&quot; href=&quot;/&quot;)            img(src=&quot;img/profile.jpg&quot; class=&quot;nofancybox&quot; width=&quot;128&quot; height=&quot;128&quot;)        h1.ttl            a(href=&quot;/&quot;)= config.title</code></pre><p>src=”img/profile.jpg” 这种路径貌似系统可以自动补<a href="https://huatingzhihoubalabalabala之类的前缀？">https://huatingzhihoubalabalabala之类的前缀？</a></p><h2 id="5-上传网站主题的background-png加载不出来"><a href="#5-上传网站主题的background-png加载不出来" class="headerlink" title="5.上传网站主题的background.png加载不出来"></a>5.上传网站主题的background.png加载不出来</h2><p>同4理，看控制台 ，底下有几个error 锁定一下， 我的在style.scss，感觉把路径改对就行，我改的是绝对路径（记得改源码里的）</p><pre><code>body &#123;  background-image: url(https://github.com/huatingzhihoudahao/blog/blob/gh-pages/img/backgroud.png);</code></pre><p>其实我的显示不出来也看不出来，因为默认就是藏蓝色，本来想换成米斯达的，但是好像这样和头像更搭一点。</p><p>淦，跨源读取阻止(CORB)功能阻止了 MIME 类型为 text/html 的跨源响应。。。。</p><p>我发现我当时截的url咋莫名其妙带了个blob，于是返回了上一级，然后拼起来，用了这个</p><pre><code>    background-image: url(https://github.com/huatingzhihoudahao/blog/tree/gh-pages/img/backgroud.png);</code></pre><p>nice~ 好使了 没报错了   </p><p>(我是后面来的 这里好了个锤子，github.com和huatingzhoudahao.github.io （这是不放域名只放图片的时候，终端显示的读取路径） 算是主域名不同？ 貌似是跨域的，我点开这个io，就是在这个io的html下，然后又设定去<a href="https://github.com/huatingzhihoudahaobalabala%E8%BF%99%E8%BE%B9%E5%8F%96%EF%BC%8C%E5%BA%94%E8%AF%A5%E5%B0%B1%E6%98%AF%E8%B7%A8%E5%9F%9F%E5%90%A7%E3%80%82%E8%B7%A8%E5%9F%9F%E6%8C%87%E7%9A%84%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8D%E8%83%BD%E6%89%A7%E8%A1%8C%E5%85%B6%E4%BB%96%E7%BD%91%E7%AB%99%E7%9A%84%E8%84%9A%E6%9C%AC%E3%80%82%E5%AE%83%E6%98%AF%E7%94%B1%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E9%80%A0%E6%88%90%E7%9A%84%EF%BC%8C%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E6%96%BD%E5%8A%A0%E7%9A%84%E5%AE%89%E5%85%A8%E9%99%90%E5%88%B6%E3%80%82%E6%89%80%E8%B0%93%E5%90%8C%E6%BA%90%E6%98%AF%E6%8C%87%EF%BC%8C%E5%9F%9F%E5%90%8D%EF%BC%8C%E5%8D%8F%E8%AE%AE%EF%BC%8C%E7%AB%AF%E5%8F%A3%E5%9D%87%E7%9B%B8%E5%90%8C)%E3%80%82">https://github.com/huatingzhihoudahaobalabala这边取，应该就是跨域吧。跨域指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器施加的安全限制。所谓同源是指，域名，协议，端口均相同)。</a>     至于关于blob什么意思为什么会出现加不加有无影响就没研究了，反正加不加都说我跨源。</p><p>举例</p><pre><code>http://www.123.com/index.html 调用 http://www.123.com/server.php （非跨域）http://www.123.com/index.html 调用 http://www.456.com/server.php （主域名不同:123/456，跨域）http://abc.123.com/index.html 调用 http://def.123.com/server.php （子域名不同:abc/def，跨域）http://www.123.com:8080/index.html 调用 http://www.123.com:8081/server.php （端口不同:8080/8081，跨域）http://www.123.com/index.html 调用 https://www.123.com/server.php （协议不同:http/https，跨域）请注意：localhost和127.0.0.1虽然都指向本机，但也属于跨域。————————————————版权声明：本文为CSDN博主「ouxiaoxian」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/ouxiaoxian/article/details/89332027</code></pre><p>这个我已经不管了。。。就这样吧懒得改了。。反正看不出有问题。。</p><p>现在的我是从第六个问题来的！！解决了！！</p><pre><code> background-image: url(https://huatingzhihoudahao.github.io/blog/img/backgroud.png);</code></pre><p>我实在是太蠢了。。。。。</p><h2 id="6-上传网站主题的头像，主页面显示出来了，点进博客里面就显示不出来"><a href="#6-上传网站主题的头像，主页面显示出来了，点进博客里面就显示不出来" class="headerlink" title="6.上传网站主题的头像，主页面显示出来了，点进博客里面就显示不出来"></a>6.上传网站主题的头像，主页面显示出来了，点进博客里面就显示不出来</h2><p>同4，5理由，控制台锁定error，发现图片位置是</p><pre><code>https://huatingzhihoudahao.github.io/blog/2021/04/30/hello-world/img/profile.jpg</code></pre><p>打开确实是没有的，我在想底下是最后生成的index.html</p><pre><code>&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/blog/js/ready.js&quot; async&gt;&lt;/script&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css&quot;&gt;&lt;body class=&quot;night&quot;&gt;&lt;div class=&quot;mobile-head&quot; id=&quot;mobile-head&quot;&gt;&lt;div class=&quot;navbar-icon&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;navbar-title&quot;&gt;&lt;a href=&quot;/&quot;&gt;LITREILY&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;navbar-search&quot;&gt;&lt;!--= show a circle here--&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;h-wrapper&quot; id=&quot;menu&quot;&gt;&lt;nav class=&quot;h-head box&quot;&gt;&lt;div class=&quot;m-hdimg&quot;&gt;&lt;a class=&quot;hdimg img&quot; href=&quot;/&quot;&gt;&lt;img class=&quot;nofancybox&quot; src=&quot;img/profile.jpg&quot;</code></pre><p>在控制台报错是GET <a href="https://huatingzhihoudahao.github.io/blog/2021/04/30/hello-world/img/profile.jpg">https://huatingzhihoudahao.github.io/blog/2021/04/30/hello-world/img/profile.jpg</a> 404      或许是因为src=”img/profile.jpg”的写法是相对路径？，</p><p>于是我把</p><pre><code>&lt;img class=&quot;nofancybox&quot; src=&quot;/img/profile.jpg&quot; width=&quot;128&quot; height=&quot;128&quot;&gt;</code></pre><p>改成</p><pre><code>img(src=&quot;https://github.com/huatingzhihoudahao/blog/tree/gh-pages/img/profile.jpg&quot;</code></pre><p>失败了。。控制台虽然没错误了，但是根本没显示出来，而且控制台报了5以及和5一样的错。。。阻止跨源响应。。。。让我怀疑我的5是不是自己看错了其实根本没解决。。</p><pre><code>跨源读取阻止(CORB)功能阻止了 MIME 类型为 text/html 的跨源响应 https://github.com/huatingzhihoudahao/blog/blob/gh-pages/img/profile.jpg。有关详细信息，请参阅 https://www.chromestatus.com/feature/5629709824032768。style.css:1 跨源读取阻止(CORB)功能阻止了 MIME 类型为 text/html 的跨源响应 https://github.com/huatingzhihoudahao/blog/blob/gh-pages/img/backgroud.png。有关详细信息，请参阅 https://www.chromestatus.com/feature/562970982403278</code></pre><p>我改成</p><pre><code> img(src=&quot;Access-Control-Allow-Origin:https://github.com/huatingzhihoudahao/blog/tree/gh-pages/img/profile.jpg&quot;</code></pre><p>也不行，说我</p><pre><code>Failed to load resource: net::ERR_UNKNOWN_URL_SCHEME</code></pre><p>估计是写法有问题，改成</p><pre><code>img(src=&quot;Access-Control-Allow-Origin:github.com/huatingzhihoudahao/blog/tree/gh-pages/img/profile.jpg&quot;</code></pre><p>一样的net::ERR_UNKNOWN_URL_SCHEME.于是加了个标签</p><pre><code>img(crossOrigin=&quot;Anonymous&quot; </code></pre><p>还是不行。。</p><p>我又全部退回去，返回到一开始的删掉斜杠</p><pre><code>&lt;img class=&quot;nofancybox&quot; src=&quot;img/profile.jpg&quot; width=&quot;128&quot; height=&quot;128&quot;&gt;</code></pre><p>img的src规则是这样的，如果是<a href="http://balablabal/img/xxx.jpg">http://balablabal/img/xxx.jpg</a>  这种系统是不会做什么的 读就直接读的这个url</p><p>但如果写img/profile.jpg，他就会默认把前面补上 当前页面的头 比如<a href="https://huatingzhihoudahao.github.io/blog/archives/img/profile.jpg">https://huatingzhihoudahao.github.io/blog/archives/img/profile.jpg</a>  补成这个样子（这个是我点击归档出来的路径）  是没有的 所以会显示不出来</p><p>如果是主页面,会补成这个样子<a href="https://huatingzhihoudahao.github.io/blog/img/profile.jpg">https://huatingzhihoudahao.github.io/blog/img/profile.jpg</a>   ，是有的，所以可以显示。如果是归档啊 关于啊 之类的 可以自己在本地搭建hexo的地方（比如我是在myblog部署的git）找source，找about啊归档啊标签啊之类的（hexo new 出来的文件夹） ，在里面新建一个img文件夹把图片扔进去。上传之后 可以保证在io上点进归档是可以显示头像的。但是md文档的点进去出不了头像怎么解决还不知道。</p><p>!!!我知道怎么解决这些问题了！！统统用<a href="https://huatingzhihoudahao.github.io/blog/img/profile.jpg%EF%BC%81%EF%BC%81">https://huatingzhihoudahao.github.io/blog/img/profile.jpg！！</a> 为什么我想绝对路径的时候只想到到github.com/balaba那个地方呢！直接io/balabala  不就行了！</p><p>n！i！c！e！！！（虽然之前的我实在是太傻了。。。怎么就脑子没转过弯来）</p><h2 id="7-根据主题作者提示安装npm-install-hexo-renderer-pug-–save的问题"><a href="#7-根据主题作者提示安装npm-install-hexo-renderer-pug-–save的问题" class="headerlink" title="7.根据主题作者提示安装npm install hexo-renderer-pug –save的问题"></a>7.根据主题作者提示安装npm install hexo-renderer-pug –save的问题</h2><h4 id="7-1出现18-packages-are-looking-for-funding-run-npm-fund-for-details"><a href="#7-1出现18-packages-are-looking-for-funding-run-npm-fund-for-details" class="headerlink" title="7.1出现18 packages are looking for funding   run npm fund for details"></a>7.1出现18 packages are looking for funding   run <code>npm fund</code> for details</h4><p>其实就是求打赏啦，可以run npm fund看链接点击去打赏，不想打赏就</p><pre><code>npm install hexo-renderer-pug --save --no-fund</code></pre><h4 id="7-2出现found-1-high-severity-vulnerability：-run-npm-audit-fix-to-fix-them-or-npm-audit-for-details"><a href="#7-2出现found-1-high-severity-vulnerability：-run-npm-audit-fix-to-fix-them-or-npm-audit-for-details" class="headerlink" title="7.2出现found 1 high severity vulnerability： run npm audit fix to fix them, or npm audit for details"></a>7.2出现found 1 high severity vulnerability： run <code>npm audit fix</code> to fix them, or <code>npm audit</code> for details</h4><p>在431扫描包中找到1个高度严重性漏洞1漏洞需要手动审查。有关详细信息，请参阅完整报告。</p><pre><code>npm audit --json</code></pre><p>查看详细报告</p><pre><code> &quot;overview&quot;: &quot;### Impact\n\nIn affected versions of `pug` and `pug-code-gen`, if a remote attacker was able to control the `pretty` option of the pug compiler, e.g. if you spread a user provided object such as the query parameters of a request into the pug template inputs, it was possible for them to achieve remote code execution on the node.js backend.\n\n### Patches\n\nUpgrade to `pug@3.0.1` or `pug-code-gen@3.0.2` or `pug-code-gen@2.0.3`, which correctly sanitise the parameter.\n\n### Workarounds\n\nIf there is no way for un-trusted input to be passed to pug as the `pretty` option, e.g. if you compile templates in advance before applying user input to them, you do not need to upgrade.&quot;,      &quot;recommendation&quot;: &quot;Upgrade `pug` to version 3.0.1&quot;,      &quot;references&quot;: &quot;- [GitHub Advisory](https://github.com/advisories/GHSA-p493-635q-r6gr)\n- [CVE](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-21353)\n- [Similar advisory for `pug-code-gen`](https://www.npmjs.com/advisories/1644)&quot;,</code></pre><p>是pug要升级（直接npm audit fix –force没用会说要手动升级）所以去references网站下载。。</p><p>网站让我直接npm install pug   版本是3.0.2   但是最后还是给我报高危漏洞要升级。。</p><p>不管了。。。。</p><p>因为我发现照着作者说的插件安了一通之后 好像没有报search xml之类的错了 </p><p>以及发现有人说npm安装的时候用cmd安装，，我用的是git bash。然而都一样都会报这个问题</p><h2 id="8-点击头像或者about之类的不能像原主题显示的那样跳转到主页面而是404"><a href="#8-点击头像或者about之类的不能像原主题显示的那样跳转到主页面而是404" class="headerlink" title="8.点击头像或者about之类的不能像原主题显示的那样跳转到主页面而是404"></a>8.点击头像或者about之类的不能像原主题显示的那样跳转到主页面而是404</h2><p>我的正确打开路径是<a href="https://huatingzhihoudahao.github.io/blog/archives/">https://huatingzhihoudahao.github.io/blog/archives/</a></p><p>点击归档之类的标签就是<a href="https://huatingzhihoudahao.github.io/blog/archives/">https://huatingzhihoudahao.github.io/blog/archives/</a></p><p>点击头像就是<a href="https://huatingzhihoudahao.github.io/blog/%E6%98%AF404">https://huatingzhihoudahao.github.io/blog/是404</a></p><p>乐哥应该在js的脚本里设的？我找了一圈没找到。之后又用4，5的方法，找到了是 a href=“  ”这类的东西，前面会被自动加上<a href="https://huatingzhihoudahao.github.io比如我写a/">https://huatingzhihoudahao.github.io比如我写a</a> href=“/blog/tags/“,就会跳转到<a href="https://huatingzhihoudahao.github.io/blog/tags/">https://huatingzhihoudahao.github.io/blog/tags/</a></p><p>于是我到nav-menu的文件里把</p><pre><code>a(class=&quot;hdimg img&quot; href=&quot;/&quot;)  和 a(href=&quot;/&quot;)= config.title</code></pre><p>改成</p><pre><code>  a(class=&quot;hdimg img&quot; href=&quot;/blog/&quot;) 和  a(href=&quot;/blog/&quot;)= config.title</code></pre><p>成功</p><p>至于about和分类或者tags点进去空的，然后对应的url又不像是错的</p><p>点进去404会告诉我</p><pre><code>If this is your site, make sure that the filename case matches the URL.For root URLs (like http://example.com/) you must provide an index.html file.</code></pre><p>那是因为根本没有hexo new，以及没有hexo d  github上就没有index.html  所以new一下上传就行</p><pre><code>hexo new page tags</code></pre><h2 id="9-插图片到文本的问题"><a href="#9-插图片到文本的问题" class="headerlink" title="9.插图片到文本的问题"></a>9.插图片到文本的问题</h2><p><a href="https://www.jianshu.com/p/f72aaad7b852">https://www.jianshu.com/p/f72aaad7b852</a></p><p><a href="https://blog.csdn.net/xjm850552586/article/details/84101345">https://blog.csdn.net/xjm850552586/article/details/84101345</a></p><p>我是5/2的我，我又回来了，这玩意解析的路径在about是对的，在post那解析的不对。。应该解析成2021/4/30balabalba它解析的是.io   欺负我不会js呗。</p><p>我看了源码和网络改进版，他们一个能出about的一个能出post的</p><p><a href="https://blog.csdn.net/xjm850552586/article/details/84101345">https://blog.csdn.net/xjm850552586/article/details/84101345</a></p><p>这个不能给about加index前缀</p><p>原版的about可以加 但是post的解析不对</p><p>这是逼着我读js啊</p><p>改成这样就好了</p><pre><code>var version = String(hexo.version).split(&#39;.&#39;);hexo.extend.filter.register(&#39;after_post_render&#39;, function(data)&#123;  var config = hexo.config;  if(config.post_asset_folder)&#123;        var link = data.permalink;    if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3)       var beginPos = getPosition(link, &#39;/&#39;, 1) + 1;    else       var beginPos = getPosition(link, &#39;/&#39;, 3) + 1;    var appendLink = &#39;&#39;;    // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.    // if not with index.html endpos = link.lastIndexOf(&#39;.&#39;) + 1 support hexo-abbrlink    if(/.*\/index\.html$/.test(link)) &#123;      // when permalink is end with index.html, for example 2019/02/20/xxtitle/index.html      // image in xxtitle/ will go to xxtitle/index/      appendLink = &#39;index/&#39;;      var endPos = link.lastIndexOf(&#39;/&#39;);    &#125;    else &#123;      var endPos = link.lastIndexOf(&#39;/&#39;) + 1;    &#125;    link = link.substring(beginPos, endPos) + &#39;/&#39; + appendLink;</code></pre><p>我是从13回来的我，这个要求config的url不带root的blog  但是这样的话 转载注明出处那里（author）会点不带root的blog的url去 也就是404了，所以为了把转载注明出处那里不搞成404，我把url改了，于是图片显示就都有问题了。也不记得具体哪行代码导致问题。。反正直接删了config.root那一项不好使。具体看13吧。。（代码都是hexo-asset-image插件里的js）</p><h2 id="10-主题段落间距和主页面标题高度显示行数的问题"><a href="#10-主题段落间距和主页面标题高度显示行数的问题" class="headerlink" title="10.主题段落间距和主页面标题高度显示行数的问题"></a>10.主题段落间距和主页面标题高度显示行数的问题</h2><p>控制台看元素，在样式里勾选和不勾选以及更改代码，可以看到效果，一般标的有源码 ，我的在style.css。下面这个是段落间距</p><pre><code>.p-content &#123;    h2,h3,h4 &#123;       // margin: 1.6em 0 0.6em;       margin: 6em 0 0.6em;</code></pre><p>max-width是页面文章标题的宽度</p><pre><code>.p-desc &#123;    position: relative;    top: 0;    left: $art-left-offset;    width: 100%;    max-width: 1000px;</code></pre><p>  font-size: 是在页面文章标题显示的字体大小</p><pre><code>h1 &#123;  font-size: 20px;  line-height: 1.2;  margin: 0 0 36px;  &#125;</code></pre><p>下面这个是显示行数</p><pre><code>.p-desc &#123;    position: relative;    top: 0;    left: $art-left-offset;    width: 100%;    max-width: $art-width;    text-align: left;    padding: $art-padding;    margin-bottom: 20px;    background: $dark-float;    box-shadow: 0 0 40px rgba(0,0,0,0.5);    display: -webkit-box;    -webkit-line-clamp: 1;    -webkit-box-orient: vertical;    overflow: hidden&#125;.l-post  article.p-art &#123;    position: relative;    top: 0;    left: $art-left-offset;    width: 100%;    max-width: $art-width;    text-align: left;    padding: $art-padding;    margin-bottom: 20px;    background: $dark-float;    box-shadow: 0 0 40px rgba(0,0,0,0.5);&#125;</code></pre><p>具体看我的回答<a href="https://www.zhihu.com/question/51632133/answer/1864334646">https://www.zhihu.com/question/51632133/answer/1864334646</a></p><h2 id="12-网页吸色"><a href="#12-网页吸色" class="headerlink" title="12.网页吸色"></a>12.网页吸色</h2><p>控制台太方便了！！以后看到好看的颜色直接开控制台在找代码吸色！在#前面有框框可以打开</p><pre><code> color: #b9549d; </code></pre><h2 id="13-为了调img显示开始现学js"><a href="#13-为了调img显示开始现学js" class="headerlink" title="13.为了调img显示开始现学js.."></a>13.为了调img显示开始现学js..</h2><p>不管怎么样 反正这个在我url不带blog root是blog的情况下  终于可以既在about里显示又在post的md里显示了。。。。我吐了。。。我这个写法就是</p><p> 默认的没改动过的src是xxx.jpg</p><p>后来把src赋值成index+src（index   就是appendLink 就是’index/‘;）  </p><p>如果当前页面是about（即下面有index文件夹且有index.xml）  就在src前面赋一个’index/‘；</p><p>这样src就是’index/xxx.jpg’               前面没有/   这种是相对路径 会被网页自动添加当前页面头</p><p>也就是会被添加成我们想要的locahost:4000  /blog/about/  + index+xx.jpg</p><p>如果src是 ‘/index/xxx.jpg’,</p><p>就不会被添加，只会结合locahost:4000  成  locahost:4000  /index+xx.jpg</p><p>如果src是about/index/xxx.jpg   </p><p>就会被添加结合成locahost:4000 /blog/about/  + about/index+xx.jpg</p><p>如果src是blog/about/index/xxx.jpg   </p><p>就会被添加结合成locahost:4000 /blog/about/  + blog/about/index+xx.jpg</p><p>反正就是前面不能带/   不然就不能补全。     ps(hexo s 可以编译输出 用console.info)</p><pre><code class="javascript">&#39;use strict&#39;;var cheerio = require(&#39;cheerio&#39;);// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123;  return str.split(m, i).join(m).length;&#125;//split这个函数是在str查找m，找到就切分 分成i段，所以会找i-1个 mvar version = String(hexo.version).split(&#39;.&#39;);hexo.extend.filter.register(&#39;after_post_render&#39;, function(data)&#123;  var config = hexo.config;  if(config.post_asset_folder)&#123;        var link = data.permalink;    // if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3)    //    var beginPos = getPosition(link, &#39;/&#39;, 1) + 1;    // else    //    var beginPos = getPosition(link, &#39;/&#39;, 3) + 1;      var beginPos = getPosition(link, &#39;/&#39;, 3) + 1;    var appendLink = &#39;&#39;;    // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.    // if not with index.html endpos = link.lastIndexOf(&#39;.&#39;) + 1 support hexo-abbrlink      // when permalink is end with index.html, for example 2019/02/20/xxtitle/index.html      // image in xxtitle/ will go to xxtitle/index/    var endPos = link.lastIndexOf(&#39;/&#39;);      //public int lastIndexOf(String str): 返回指定子字符串在此字符串中最右边出现处的索引，如果此字符串中没有这样的字符，则返回 -1。      //比如这里本来是https://huatingzhihoudahao.github.io/blog/about/index.html   是截止到about        if(/.*\/index\.html$/.test(link)) &#123;      // when permalink is end with index.html, for example 2019/02/20/xxtitle/index.html      // image in xxtitle/ will go to xxtitle/index/     // appendLink =link.substring(beginPos, endPos)+ &#39;/index/&#39;;     appendLink =&#39;index/&#39;;     //appendLink =&#39;/index/&#39;;         &#125;    else &#123;    &#125;    //link = link.substring(beginPos, endPos) + &#39;/&#39; + appendLink;    link = appendLink;    var toprocess = [&#39;excerpt&#39;, &#39;more&#39;, &#39;content&#39;];    for(var i = 0; i &lt; toprocess.length; i++)    &#123;      var key = toprocess[i];       var $ = cheerio.load(data[key], &#123;        ignoreWhitespace: false,        xmlMode: false,        lowerCaseTags: false,        decodeEntities: false      &#125;);      $(&#39;img&#39;).each      (function()        &#123;                      if ($(this).attr(&#39;src&#39;))//这个意思是返回这个节点（此处为img）的src属性的值                      //src就是xxx.jpg                      //$(this).attr(key); 获取节点属性名的值，相当于getAttribute(key)方法                       &#123;                              // For windows style path, we replace &#39;\&#39; to &#39;/&#39;.                              var src = $(this).attr(&#39;src&#39;).replace(&#39;\\&#39;, &#39;/&#39;); //var是申明变量                              if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp;!/^\s*\//.test(src))                              &#123;                                // For &quot;about&quot; page, the first part of &quot;src&quot; can&#39;t be removed.                                // In addition, to support multi-level local directory.                                var linkArray = link.split(&#39;/&#39;).filter(function(elem)                                //split不改变原本link的值                                                                                      &#123;                                                                                      return elem != &#39;&#39;;                                                                                      &#125;                                                                      );                          //   var srcArray = src.split(&#39;/&#39;).filter(function(elem)                          //                                                       &#123;                          //                                                       return elem != &#39;&#39; &amp;&amp; elem != &#39;.&#39;;                          //                                                       &#125;                          //                                       );                          //   if(srcArray.length &gt; 1)                          //   srcArray.shift();                          //   //shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。                          //  // src = srcArray;                          //   src = srcArray.join(&#39;/&#39;);                               // $(this).attr(&#39;src&#39;,   src);                               console.info&amp;&amp;console.info(link+&quot;&lt;/br&gt;&quot;);                                $(this).attr(&#39;src&#39;,   link+src);                                 //$(this).attr(key, value); 设置节点属性的值，相当于setAttribute(key,value)方法                                 console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+link + src);                              &#125;                      &#125;                      else                      &#123;                        console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;);                        console.info&amp;&amp;console.info($(this));                      &#125;        &#125;      );      data[key] = $.html();    &#125;  &#125;&#125;);</code></pre><p>调试的过程中学了一点点点点js</p><p><img src="js-split.png" alt="G2"></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -hexo搭建中的bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo指令</title>
      <link href="/blog/2021/04/30/hello-world/"/>
      <url>/blog/2021/04/30/hello-world/</url>
      
        <content type="html"><![CDATA[<p>记得指令都在部署git的文件下，我的是myblog 。三件套 hexo clean/ hexo g/ hexo d 不过网不好可能d不上去，再多试试</p><p>host new post xxx   建一个新的md，如果安装hexo-asset-image插件之后会自动创一个同名的文件夹用来放图片</p><p>host new page xxx 建一个新的page，如果想要添加到左边导航栏，需要自己在主题的_config里面更改 比如这个是我用的snark主题的meua  reference是我新加的 。new一个新page然后编译上传之后就会出现一个新的 一大堆前缀/blog/xxx/ 页面可以访问了。</p><pre><code>menu:  - page: 归档    directory: archives/  - page: 分类    directory: categories/  - page: 标签    directory: tags/  - page: 关于    directory: about/  - page: 参考书    directory: reference/  - page: rss    directory: atom.xml</code></pre><p>想插入pdf就百度一下 安一个pdf的插件，然后把pdf扔进source里，想在md里插pdf就写好绝对路径就行</p><p><img src="1.jpg" alt="1"></p><h4 id="Welcome-to-Hexo-This-is-your-very-first-post-Check-documentation-for-more-info-If-you-get-any-problems-when-using-Hexo-you-can-find-the-answer-in-troubleshooting-or-you-can-ask-me-on-GitHub"><a href="#Welcome-to-Hexo-This-is-your-very-first-post-Check-documentation-for-more-info-If-you-get-any-problems-when-using-Hexo-you-can-find-the-answer-in-troubleshooting-or-you-can-ask-me-on-GitHub" class="headerlink" title="Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub."></a>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</h4><h1 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h1><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -hexo指令 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
