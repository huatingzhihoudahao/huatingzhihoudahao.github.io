<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我要做秧歌star的钢琴！</title>
  
  
  <link href="https://huatingzhihoudahao.github.io/blog/atom.xml" rel="self"/>
  
  <link href="https://huatingzhihoudahao.github.io/blog/"/>
  <updated>2021-05-04T20:10:03.236Z</updated>
  <id>https://huatingzhihoudahao.github.io/blog/</id>
  
  <author>
    <name>做秧歌star的钢琴</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>大统一之用vscode开发单片机的platformio</title>
    <link href="https://huatingzhihoudahao.github.io/blog/2021/05/04/%E5%A4%A7%E7%BB%9F%E4%B8%80%E4%B9%8B%E7%94%A8vscode%E5%BC%80%E5%8F%91%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84platformio/"/>
    <id>https://huatingzhihoudahao.github.io/blog/2021/05/04/%E5%A4%A7%E7%BB%9F%E4%B8%80%E4%B9%8B%E7%94%A8vscode%E5%BC%80%E5%8F%91%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84platformio/</id>
    <published>2021-05-03T19:52:04.000Z</published>
    <updated>2021-05-04T20:10:03.236Z</updated>
    
    <content type="html"><![CDATA[<p>这回本来打算用msp432，一开始我设备那显示无驱动，我就跑去官网找 没找到。于是为了确定这个到底能不能直接用，我去云端ccs建了个工程编译烧录了一下。</p><p>但是。。过程中好像弹出来一个ccs的程序访问请求，我允许了，能烧录，回来一看设备运转正常。感觉是那个程序的原因。 </p><p>但是我发现platformio不支持432。。。</p><p>所以这回还是tivac。</p><h3 id="先上pinmap"><a href="#先上pinmap" class="headerlink" title="先上pinmap"></a>先上pinmap</h3><p><img src="2.jpg" alt="image-20210504033843670"></p><h3 id="PIO初建"><a href="#PIO初建" class="headerlink" title="PIO初建"></a>PIO初建</h3><p>platformio是vscode的插件，可以全员变成arduino的框架，基本什么板子都有，统统封装成arduino的库。</p><p>vscode拓展安装platformio。安装完之后重启vscode，点外星人图标，点PIO home，新建一个project，选好板子型号和框架，生成的位置，PIO 会自动根据选择的 Board 和 Framework 配置工程并且下载需要用到的编译工具，需要的编译依赖什么的 PIO 通通帮我们搞定，一段时间过后工程就新建完成了。比如看它给我们配的配置，</p><p><img src="3.jpg" alt="image-20210504033843670"></p><p>这里的libdeps一开始是空的，后面有用第三方库就自己安装（后面那个是我注释的）</p><p>打开 <code>src</code> 文件夹下的 <code>main.cpp</code>，比如写一个亮灯的程序</p><h3 id="先找引脚"><a href="#先找引脚" class="headerlink" title="先找引脚"></a>先找引脚</h3><p>点进arduino.h  这个是它根据我们的选型给弄得一个从tivac封装到arduino的库，点进energia.h  点进末尾的pins_energia.h就可以看到对应的引脚了。其实最好自己对着pinmap看，因为如果是和别的型号通用的话有的时候不一定对？</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="c">#include &lt;Arduino.h&gt;void setup() &#123;  // put your setup code here, to run once:  pinMode(RED_LED, OUTPUT);  pinMode(BLUE_LED, OUTPUT);&#125;void loop() &#123;  // put your main code here, to run repeatedly:  digitalWrite(RED_LED, HIGH);  digitalWrite(BLUE_LED, HIGH);  delay(1000);  digitalWrite(RED_LED, LOW);  digitalWrite(BLUE_LED, HIGH);  delay(1000);&#125;</code></pre><p><img src="4.jpg" alt="image-20210504033843670"></p><p>点这个√就可以编译啦，-&gt;就是烧录咯</p><h3 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h3><p>比如我现在想用TFT屏幕，就去了pio home的libraries搜tft。有个adafruit ILI9341，</p><p>就用这家的吧 adafruit做了很多库。</p><p><img src="5.jpg" alt="image-20210504033843670"></p><p>选好版本，点add to project 就会自动添加到platformio.ini，  配置文件里只会添加这一个库</p><p><img src="6.jpg" alt="image-20210504033843670"></p><p>而libdeps会有其他四个标题添加进来，这些都是adafruit ILI9341所依赖的库。在library.properties 会写他依赖了什么。但它的依赖又会依赖别的东西，反正套娃完就是四个了</p><p><img src="7.jpg" alt="image-20210504033843670"></p><p><img src="8.jpg" alt="image-20210504033843670"></p><p>这个时候就需要我们把这其他的四个添加到ini配置里去了</p><p><img src="9.jpg" alt="image-20210504033843670"></p><p>看library.properties 这个文件里有这个第三方库的name和 version</p><p>看.piopm也可以。挨个找完补到配置里去</p><p><img src="10.jpg" alt="image-20210504033843670"></p><p>尝试编译，由于ini配置里指定了依赖，所以新加的库也都会被编译。</p><p><img src="11.jpg" alt="image-20210504033843670"></p><p><img src="12.jpg" alt="image-20210504033843670"></p><p>这个时候就有意思了，会发现，欸？怎么还找不到wire.h和spi.h？ 这又是啥？</p><p>这其实是tiva的官方库。</p><h3 id="来解释一下energia官方为了让我们能把tivac当成arduino开发提供了什么东西。"><a href="#来解释一下energia官方为了让我们能把tivac当成arduino开发提供了什么东西。" class="headerlink" title="来解释一下energia官方为了让我们能把tivac当成arduino开发提供了什么东西。"></a>来解释一下energia官方为了让我们能把tivac当成arduino开发提供了什么东西。</h3><p>看过energia博客的应该知道，energia是TI做的一个把自己家板子包装成arduino的framework的一个平台，比如我们在用tivac的时候需要在开发板管理器那下载对应的包装</p><p><img src="13.jpg" alt="image-20210504033843670"></p><p>这样在示例中会有core，确保tivac可以用arduino的开发方式开发。</p><p><img src="14.jpg" alt="image-20210504033843670"></p><p>把文件首选项中的显示详细输出勾上</p><p><img src="15.jpg" alt="image-20210504033843670"></p><p>跑一个内置实例blink 会看到底下说它</p><pre><code class="c">Using core &#39;tivac&#39; from platform in folder: C:\Users\19735\AppData\Local\Energia15\packages\energia\hardware\tivac\1.0.4</code></pre><p>打开相应位置 ，这里就是我们在开发板管理器那下载的对应的东西</p><p><img src="17.jpg" alt="image-20210505032903466"></p><p>core里有arduino.h energia.h ;variants里有pins_energia.h 这些就就是我们在前面新建一个不加第三方库的时候看引脚用的。  而libraries就是 实例里多的那些tivac的库  这些都是tivac官方在energia里提供给我们的。在libraries里面有SPI,有WIFI，自然也有SPI.h  WIFI.h</p><h3 id="再来看platformio里TIVAC的官方库扮演了什么角色"><a href="#再来看platformio里TIVAC的官方库扮演了什么角色" class="headerlink" title="再来看platformio里TIVAC的官方库扮演了什么角色"></a>再来看platformio里TIVAC的官方库扮演了什么角色</h3><p>也没啥，就是官方库而已，官方库和第三方库的区别. 看底下这个framework-energiativa，就是一个在板子选型的时候就已经built-in了，一个需要在registry里搜了自己安装。</p><p><img src="18.jpg" alt="image-20210505032903466"></p><p>至于官方这个库在选型初建工程的时候被放在哪了呢？还记得找引脚的时候的pin_energia吧，</p><p><img src="19.jpg" alt="image-20210505032903466"></p><p>这就是他的路径。</p><p>而就像energia里，这些库我们不选他做例程，也不会include，所以在platformio里，如果用到这些库，都是需要手动添加到ini配置里的.</p><p><img src="20.jpg" alt="image-20210505032903466"></p><p>现在库都添加完咯</p><p>开心的编译，结果发现出现一大堆错误呢。</p><p><img src="21.jpg" alt="image-20210505032903466"></p><pre><code class="c">// some modern SPI definitions don&#39;t have BitOrder enum#if (defined(__AVR__) &amp;&amp; !defined(ARDUINO_ARCH_MEGAAVR)) ||                    \    defined(ESP8266) || defined(TEENSYDUINO) || defined(SPARK) ||              \    defined(ARDUINO_ARCH_SPRESENSE) || defined(MEGATINYCORE) ||                \    defined(DXCORE) || defined(ARDUINO_AVR_ATmega4809) ||                      \    defined(ARDUINO_AVR_ATmega4808) || defined(ARDUINO_AVR_ATmega3209) ||      \    defined(ARDUINO_AVR_ATmega3208) || defined(ARDUINO_AVR_ATmega1609) ||      \    defined(ARDUINO_AVR_ATmega1608) || defined(ARDUINO_AVR_ATmega809) ||       \    defined(ARDUINO_AVR_ATmega808)typedef enum _BitOrder &#123;  SPI_BITORDER_MSBFIRST = MSBFIRST,  SPI_BITORDER_LSBFIRST = LSBFIRST,&#125; BitOrder;#elif defined(ESP32) || defined(__ASR6501__)// some modern SPI definitions don&#39;t have BitOrder enum and have different SPI// mode definestypedef enum _BitOrder &#123;  SPI_BITORDER_MSBFIRST = SPI_MSBFIRST,  SPI_BITORDER_LSBFIRST = SPI_LSBFIRST,&#125; BitOrder;#else// Some platforms have a BitOrder enum but its named MSBFIRST/LSBFIRST#define SPI_BITORDER_MSBFIRST MSBFIRST#define SPI_BITORDER_LSBFIRST LSBFIRST#endif#if defined(__AVR__) || defined(TEENSYDUINO)typedef volatile uint8_t BusIO_PortReg;typedef uint8_t BusIO_PortMask;#define BUSIO_USE_FAST_PINIO#elif defined(ESP8266) || defined(ESP32) || defined(__SAM3X8E__) ||            \    defined(ARDUINO_ARCH_SAMD)typedef volatile uint32_t BusIO_PortReg;typedef uint32_t BusIO_PortMask;#define BUSIO_USE_FAST_PINIO#elif (defined(__arm__) || defined(ARDUINO_FEATHER52)) &amp;&amp;                      \    !defined(ARDUINO_ARCH_MBED) &amp;&amp; !defined(ARDUINO_ARCH_RP2040)typedef volatile uint32_t BusIO_PortReg;typedef uint32_t BusIO_PortMask;#if not defined(__ASR6501__)#define BUSIO_USE_FAST_PINIO#endif#else#undef BUSIO_USE_FAST_PINIO#endif/**! The class which defines how we will talk to this device over SPI **/class Adafruit_SPIDevice &#123;public:  Adafruit_SPIDevice(int8_t cspin, uint32_t freq = 1000000,                     BitOrder dataOrder = SPI_BITORDER_MSBFIRST,                     uint8_t dataMode = SPI_MODE0, SPIClass *theSPI = &amp;SPI);  Adafruit_SPIDevice(int8_t cspin, int8_t sck, int8_t miso, int8_t mosi,                     uint32_t freq = 1000000,                     BitOrder dataOrder = SPI_BITORDER_MSBFIRST,                     uint8_t dataMode = SPI_MODE0);  ~Adafruit_SPIDevice();  bool begin(void);  bool read(uint8_t *buffer, size_t len, uint8_t sendvalue = 0xFF);  bool write(uint8_t *buffer, size_t len, uint8_t *prefix_buffer = NULL,             size_t prefix_len = 0);  bool write_then_read(uint8_t *write_buffer, size_t write_len,                       uint8_t *read_buffer, size_t read_len,                       uint8_t sendvalue = 0xFF);  uint8_t transfer(uint8_t send);  void transfer(uint8_t *buffer, size_t len);  void beginTransaction(void);  void endTransaction(void);private:  SPIClass *_spi;  SPISettings *_spiSetting;  uint32_t _freq;  BitOrder _dataOrder;  uint8_t _dataMode;  int8_t _cs, _sck, _mosi, _miso;#ifdef BUSIO_USE_FAST_PINIO  BusIO_PortReg *mosiPort, *clkPort, *misoPort, *csPort;  BusIO_PortMask mosiPinMask, misoPinMask, clkPinMask, csPinMask;#endif  bool _begun;&#125;;#endif // Adafruit_SPIDevice_h</code></pre><p>看前面defined那些，只有过了defined才能给我们申明BitOrider类，然而根本没有带我们__TM4C123GH6PM__玩呢。</p><p>咱们强行硬插一下TM4C123GH6PM   这个怎么写看这个PIO的tivac工程给我们提供的energia.h</p><pre><code>#if (defined(__AVR__) &amp;&amp; !defined(ARDUINO_ARCH_MEGAAVR)) ||                    \    defined(ESP8266) || defined(TEENSYDUINO) || defined(SPARK) ||              \    defined(ARDUINO_ARCH_SPRESENSE) || defined(MEGATINYCORE) ||                \    defined(DXCORE) || defined(ARDUINO_AVR_ATmega4809) ||                      \    defined(ARDUINO_AVR_ATmega4808) || defined(ARDUINO_AVR_ATmega3209) ||      \    defined(ARDUINO_AVR_ATmega3208) || defined(ARDUINO_AVR_ATmega1609) ||      \    defined(ARDUINO_AVR_ATmega1608) || defined(ARDUINO_AVR_ATmega809) ||       \    defined(ARDUINO_AVR_ATmega808)  || defined(__TM4C123GH6PM__)typedef enum _BitOrder &#123;  SPI_BITORDER_MSBFIRST = MSBFIRST,  SPI_BITORDER_LSBFIRST = LSBFIRST,&#125; BitOrder;</code></pre><p>开心编译，结果好家伙，这回这个adafruit的库说我们没有SPISettings的函数，我这去它include的SPI.h查了一圈，还真没有。我就在想会不会是因为它是tivac所以没有，没有封装。于是我去新建了一个本来就是arduino工程的，它的spi.h还真有这个函数。</p><p>这个时候我福临心智，去看看energia的tiva官方给我们的spi.h里有没有把。被我这一看，还真有。。</p><p>昊佳告诉我很有可能是官方的可能更新了，plantform的没更新。</p><p>我把spi.h覆盖掉了，但是又有新的没命名的错，是pin_energia.h的不一样。。我又去替换，结果又有错。我要吐啦。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这回本来打算用msp432，一开始我设备那显示无驱动，我就跑去官网找 没找到。于是为了确定这个到底能不能直接用，我去云端ccs建了个工程编译烧录了一下。&lt;/p&gt;
&lt;p&gt;但是。。过程中好像弹出来一个ccs的程序访问请求，我允许了，能烧录，回来一看设备运转正常。感觉是那个程序的</summary>
      
    
    
    
    <category term="嵌入式开发环境" scheme="https://huatingzhihoudahao.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    
    
    <category term="vscode" scheme="https://huatingzhihoudahao.github.io/blog/tags/vscode/"/>
    
    <category term="platformio" scheme="https://huatingzhihoudahao.github.io/blog/tags/platformio/"/>
    
    <category term="全员arduino" scheme="https://huatingzhihoudahao.github.io/blog/tags/%E5%85%A8%E5%91%98arduino/"/>
    
  </entry>
  
  <entry>
    <title>energia开发环境</title>
    <link href="https://huatingzhihoudahao.github.io/blog/2021/05/04/energia%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>https://huatingzhihoudahao.github.io/blog/2021/05/04/energia%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</id>
    <published>2021-05-03T19:34:07.000Z</published>
    <updated>2021-05-03T23:31:16.068Z</updated>
    
    <content type="html"><![CDATA[<p>这回用的TIVAC，直接烧录是烧录不进去的，会发现设备根本没有配置好，需要手动安装驱动，驱动去TI官网找</p><p><a href="https://www.ti.com.cn/tool/cn/STELLARIS_ICDI_DRIVERS#supp-products-hw-dl">https://www.ti.com.cn/tool/cn/STELLARIS_ICDI_DRIVERS#supp-products-hw-dl</a></p><p>先去energia官网下个pinmap</p><p><img src="2.jpg" alt="image-20210504033843670"></p><p>这回主要是讲怎么energia开发</p><p>它可以支持TI家基本所有的板子，而且不必读寄存器或者看库函数，直接arduino开发，但是没有断点，以及库其实没有那么全备，很多都是一些冷门的外设的库，（或许不是冷门只是我孤陋寡闻？）</p><p>下载energia</p><p><a href="https://energia.nu/download/">https://energia.nu/download/</a></p><p>点工具-&gt; 开发板管理器-&gt;下载想要的板子  </p><p><img src="1.jpg" alt="image-20210504033843670"></p><p>然后工具-&gt;开发板-&gt;选中自己的板子</p><p>然后文件 示例 选自己想要的模板开始开发吧  右上角是串口显示，这里没法断点调试</p><p>效果</p><p><img src="3.jpg" alt="image-20210504033843670"></p><p>energia官网有函数。<a href="https://energia.nu/reference/">https://energia.nu/reference/</a>  基本等于arduino开发，就是得对着pinmap看引脚，有的时候为了库通用，给出来的不一定能用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这回用的TIVAC，直接烧录是烧录不进去的，会发现设备根本没有配置好，需要手动安装驱动，驱动去TI官网找&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.ti.com.cn/tool/cn/STELLARIS_ICDI_DRIVERS#supp-products-h</summary>
      
    
    
    
    <category term="嵌入式开发环境" scheme="https://huatingzhihoudahao.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    
    
    <category term="energia" scheme="https://huatingzhihoudahao.github.io/blog/tags/energia/"/>
    
  </entry>
  
  <entry>
    <title>msp430g2之示波器(ADC UART)</title>
    <link href="https://huatingzhihoudahao.github.io/blog/2021/05/04/msp430g2%E4%B9%8B%E7%A4%BA%E6%B3%A2%E5%99%A8/"/>
    <id>https://huatingzhihoudahao.github.io/blog/2021/05/04/msp430g2%E4%B9%8B%E7%A4%BA%E6%B3%A2%E5%99%A8/</id>
    <published>2021-05-03T17:28:32.000Z</published>
    <updated>2021-05-03T19:30:03.148Z</updated>
    
    <content type="html"><![CDATA[<p>用的RX TX   P1_1  P1_2  和串口屏RX接TX    TX 接RX       波特率115200</p><p>ADC用的是1.4通道。</p><p><img src="LaunchPadMSP430G2553.jpg" alt="G2"> </p><p>从energia官网下载的pinmaps（energia是一个高度类似arduino的编译环境，虽然不能断点调试只能串口调试，但是官网这个真的香，TI家的板子大部分都有，而且还能导入到ccs调试）。</p><h3 id="先过一遍通信原理吧"><a href="#先过一遍通信原理吧" class="headerlink" title="先过一遍通信原理吧"></a>先过一遍通信原理吧</h3><h4 id="并行串行"><a href="#并行串行" class="headerlink" title="并行串行"></a>并行串行</h4><p>并行通讯：同一时刻，可以传输多个bit位的信号，有多少个信号位就需要多少根信号线。</p><p>串行通讯：同一时刻，只能传输一个bit位的信号，只需要一根信号线。</p><h4 id="同步异步"><a href="#同步异步" class="headerlink" title="同步异步"></a>同步异步</h4><p>异步通信，是指通信双方按照事前约定好的时钟速率（波特率）来进行通信，因为没有公共的时钟线，所以通信双方的数据必须“整齐划一”。比如uart就是异步通信。而IIC  SPI都需要时钟线 是同步通信。而stm32的usart则是通用同步和异步收发器，可以主动提供时钟，既可以当uart用也可以当spi用</p><p>而同步通信的双方拥有公共时钟，按时钟信号来更新数据，所以数据流不一定要“整齐划一”。比如IIC SPI</p><h4 id="单工双工"><a href="#单工双工" class="headerlink" title="单工双工"></a>单工双工</h4><p>同时收发就是全双工，比如打电话。</p><p>数据能收能发，但要分时进行就是半双工，比如对讲机。</p><p>只能单向通信就是单工了，比如广播。</p><h3 id="UART特性"><a href="#UART特性" class="headerlink" title="UART特性"></a>UART特性</h3><p>uart属于串行，异步（无需时钟线），全双工（加上它是串行，所以有两条数据线，一个TX 一个RX）</p><p><img src="%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.jpg" alt="G2"> </p><p><img src="uart%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE.jpg" alt="G2"> </p><p>我们写的是八位的数据位</p><p><img src="UARTbuf.jpg" alt="G2"> </p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="c">#include &lt;msp430.h&gt;     int i=0;    int x=0;    //double p=0;    float volt=0;    int trans=0;    short temp[180]=&#123;&#125;;    short compare[6]=&#123;&#125;;    float y=0;void UART_INIT()         //初始化UART端口&#123;      P1SEL |= BIT1 + BIT2 ;                    // P1.1 = RXD, P1.2=TXD      P1SEL2 |= BIT1 + BIT2 ;                   // P1.1 = RXD, P1.2=TXD     UCA0CTL1 |= UCSSEL_2;                     // 选择SMCLK(1MHz)作为时钟源      UCA0BR0 = 139;                              // 8MHz 115200      UCA0BR1 = 0;                              // 8MHz 115200      UCA0MCTL = UCBRS2 + UCBRS0;               // Modulation UCBRSx = 5      UCA0CTL1 &amp;= ~UCSWRST;                     // USCI 软件复位      IE2 |= UCA0RXIE;                          // 使能USCI_A0 RX中断&#125;void SendString(char *s)     //UART发送字符串&#123;    while(*s!=&#39;\0&#39;)    &#123;        UCA0TXBUF = *(s++);        __delay_cycles(1500);    &#125;&#125;void ClearScreen()&#123;    __delay_cycles(1000);    SendString(&quot;CLS(0);\x0d\x0a&quot;);         //Caution:\x0d\x0a    __delay_cycles(1000);&#125;void line(int x,int y,int z)//z是上一个点的纵坐标&#123;    //    PL(x-1,z,x,y,1)    //        0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15   16  17  18  19    char l[]=&#123;&#39;P&#39;,&#39;L&#39;,&#39;(&#39;,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;,&#39;,&#39;z&#39;,&#39;z&#39;,&#39;z&#39;,&#39;,&#39;,&#39;x&#39;,&#39;x&#39;,&#39;x&#39;,&#39;,&#39;,&#39;y&#39;,&#39;y&#39;,&#39;y&#39;,&#39;,&#39;,&#39;1&#39;,&#39;)&#39;,&#39;;&#39;,&#39;\x0d&#39;,&#39;\x0a&#39;,&#39;\0&#39;&#125;;    l[3]=(x-1)/100+48;    l[4]=((x-1)%100)/10+48;    l[5]=(x-1)%10+48;    l[7]=z/100+48;    l[8]=(z%100)/10+48;    l[9]=z%10+48;    l[11]=x/100+48;    l[12]=(x%100)/10+48;    l[13]=x%10+48;    l[15]=y/100+48;    l[16]=(y%100)/10+48;    l[17]=y%10+48;       SendString(l);    __delay_cycles(1000);&#125;void free(int x)&#123;//            0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15    char l[]=&#123;&#39;P&#39;,&#39;L&#39;,&#39;(&#39;,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;,&#39;,&#39;0&#39;,&#39;,&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;,&#39;,&#39;2&#39;,&#39;2&#39;,&#39;0&#39;,&#39;,&#39;,&#39;0&#39;,&#39;)&#39;,&#39;;&#39;,&#39;\x0d&#39;,&#39;\x0a&#39;,&#39;\0&#39;&#125;;//BOXF(x-1,0,x+2,239,0)//    PL(X,0,X,220,0)    l[3]=x/100+48;    l[4]=(x%100)/10+48;    l[5]=x%10+48;    l[9]=x/100+48;    l[10]=(x%100)/10+48;    l[11]=x%10+48;       SendString(l);    __delay_cycles(1000);&#125;void Sendpoint(int x,int y)&#123;       char B[]=&#123;&#39;P&#39;,&#39;S&#39;,&#39;(&#39;,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;,&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;,&#39;,&#39;1&#39;,&#39;)&#39;,&#39;;&#39;,&#39;\x0d&#39;,&#39;\x0a&#39;,&#39;\0&#39;&#125;; B[3]=x/100+48; B[4]=(x%100)/10+48; B[5]=x%10+48; B[7]=y/100+48; B[8]=(y%100)/10+48; B[9]=y%10+48;       SendString(B); //   __delay_cycles(1000);&#125;/*初始化屏幕显示函数,返回主界面时调用*/void ScreenInit(int x,int y,int trans)&#123;   char c[]=&#123;&#39;D&#39;,&#39;S&#39;,&#39;1&#39;,&#39;6&#39;,&#39;(&#39;,&#39;2&#39;,&#39;4&#39;,&#39;0&#39;,&#39;,&#39;,&#39;5&#39;,&#39;0&#39;,&#39;,&#39;,&#39;\&#39;&#39;,&#39;a&#39;,&#39;.&#39;,&#39;c&#39;,&#39;d&#39;,&#39;V&#39;,&#39;\&#39;&#39;,&#39;,&#39;,&#39;1&#39;,&#39;)&#39;,&#39;;&#39;,&#39;\x0d&#39;,&#39;\x0a&#39;,&#39;\0&#39;&#125;;//前面发的是2 4 0 的asc   c[13]=trans/100+48;   c[15]=(trans%100)/10+48;   c[16]=trans%10+48;  SendString(c);  Sendpoint(x,y);&#125; int j;  int z=0;int main()&#123;    WDTCTL = WDTPW | WDTHOLD;   // stop watchdog timer    BCSCTL1 = CALBC1_16MHZ;    DCOCTL = CALDCO_16MHZ;     UART_INIT();     __delay_cycles(1000);     ClearScreen();     SendString(&quot;PL(5,5,5,239,1);\x0d\x0a&quot;);     SendString(&quot;PL(0,230,319,230,1);\x0d\x0a&quot;);      SendString(&quot;DS12(290,210,&#39;t&#39;,1);\x0d\x0a&quot;);     SendString(&quot;DS12(9,5,&#39;u&#39;,1);\x0d\x0a&quot;);        //  SendString(&quot;TPN(2);\x0d\x0a&quot;);//发回区域编码        //  SendString(&quot;BTN(2,250,155,318,200,1);\x0d\x0a&quot;);//跑飞        //  SendString(&quot;DS48(253,175,&#39;跑飞&#39;,1,0);\x0d\x0a&quot;);        //  SendString(&quot;BTN(1,250,100,318,145,3,0);\x0d\x0a&quot;);//正常        //  SendString(&quot;DS48(253,115,&#39;正常&#39;,1,0);\x0d\x0a&quot;);        // _EINT();    //开总中断   ADC10CTL0 &amp;= ~ENC;//配置前先关   //ADC10CTL0 =ADC10ON + ADC10IE; // ADC10ON, interrupt enabled   ADC10CTL0 =ADC10SHT_3+ADC10ON + ADC10IE;//ADC的中断开      //这里sref值默认0，基准电压是VCC3.3和GND,四个时钟周期，   ADC10CTL1 = INCH_4+ADC10SSEL_3; // input A4,接1.4,SMCLK子时钟//采样周期0.00000025s,示波器10khz  0.0001s，采180个点，两次之间0.000000555s,所以要0.000000145s中断//单通道单次采样      ADC10AE0 |= BIT4;          // PA.4 ADC option select    while(1) &#123;        // ADC10CTL0 |= ENC + ADC10SC;             // 打开ADC         while(1)      &#123;      //采5个点             for(j=0;j&lt;=4;j++)          &#123;                 ADC10CTL0 |= ENC + ADC10SC;             compare[j]=ADC10MEM;                __delay_cycles(100);//采样还是比较快的，           // 打开ADC          &#125;          if ((compare[2]&gt;compare[3])&amp;&amp;(compare[2]&gt;compare[4])&amp;&amp;(compare[2]&gt;compare[1])&amp;&amp;(compare[2]&gt;compare[0]))         &#123;               break;         &#125;     &#125;   //采集180个点         for(i=0;i&lt;180;i++)     &#123;             ADC10CTL0 |= ENC + ADC10SC;             // 打开ADC             __delay_cycles(100);             temp[i]=ADC10MEM;//乘法计算花时间，直接赋值，不要在这个for里面算*10     &#125;   //把180个点打出去    for(i=0;i&lt;180;i++)    &#123;        if(x&lt;180)       &#123;        y=239-(temp[i]*10/1024.0)*23.9;        if((i-1)&gt;=0&amp;&amp;(x-1)&gt;=0)        &#123;            z=239-(temp[i-1]*10/1024.0)*23.9;        line(x,y,z);        &#125;         volt=((temp[i]*10/1024.0))*3.3;        trans=volt*10;         __delay_cycles(1000);         free(x);         SendString(&quot;PL(5,5,5,239,1);\x0d\x0a&quot;);          SendString(&quot;DS12(9,5,&#39;u&#39;,1);\x0d\x0a&quot;);            SendString(&quot;PL(0,230,319,230,1);\x0d\x0a&quot;);         SendString(&quot;DS12(290,210,&#39;t&#39;,1);\x0d\x0a&quot;);        //  SendString(&quot;TPN(2);\x0d\x0a&quot;);//发回区域编码        //  SendString(&quot;BTN(2,250,155,318,200,1);\x0d\x0a&quot;);//跑飞        //  SendString(&quot;DS48(253,175,&#39;跑飞&#39;,1,0);\x0d\x0a&quot;);        //  SendString(&quot;BTN(1,250,100,318,145,3,0);\x0d\x0a&quot;);//正常        //  SendString(&quot;DS48(253,115,&#39;正常&#39;,1,0);\x0d\x0a&quot;);        ScreenInit(x,y,trans);        x++;       __delay_cycles(1000);       &#125;        else   x=0;    &#125;  //    __enable_interrupt();&#125;&#125;#pragma vector=USCIAB0RX_VECTOR__interrupt void USCI0RX_ISR(void)&#123;    unsigned char rxbuff = UCA0RXBUF;         // 读取RXBUF    IFG2&amp;=~UCA0RXIFG;//     if(rxbuff == &#39;1&#39;) //正常//         &#123;ClearScreen();&#125;// //    &#123;    SendString(&quot;DS48(50,50,&#39;正常&#39;,1,0);\x0d\x0a&quot;);// //    __delay_cycles(50000);&#125;//     if(rxbuff == &#39;2&#39;)//跑飞//     &#123;  SendString(&quot;DS48(50,50,&#39;跑飞&#39;,1,0);\x0d\x0a&quot;);//     __delay_cycles(50000);&#125;&#125;#pragma vector=ADC10_VECTOR__interrupt void ADC10_ISR(void)&#123;    //static double p=0;    //     p++;&#125;</code></pre><p><img src="%E6%95%88%E6%9E%9C.jpg" alt="G2"> </p><p>这里的按钮热区都被我注释掉了，原因是没有解析[BN:X]       大概得用这种方式解析一下？</p><pre><code class="c">#pragma vector=USCI_A0_VECTOR//2553是AB0_TX有一个，AB0_RX有一个中断向量，可能本来AB是共用的，但好像2553是没用B，嗷，我也不知道//反正现在5529是TX RX共用一中断向量，要查表看响应的哪个__interrupt void USCIA0_ISR(void)&#123;   static unsigned char rxbuff=123;   static unsigned int number;    switch(__even_in_range(UCA0IV,4))      &#123;      case 0:  break;                             // Vector 0 - no interrupt      case 2:            rxbuff = UCA0RXBUF;         // 读取RXBUF            UCA0IFG&amp;=~UCRXIFG;            if(rxbuff == &#39;[&#39;)            &#123;   iscmd=1;                number=0;            &#125;            else if(rxbuff == &#39;]&#39;)            &#123;  iscmd=0;               iscmdok=1;            &#125;            else if(iscmd==1)                       &#123;  cmd[number]=rxbuff;                         number++;                       &#125;          break;                                 // Vector 2 - RXIFG      case 4:    break;                             // Vector 4 - TXIFG      default: break;      &#125;&#125;</code></pre><p>写UI应结合gpumaker和状态机一起用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;用的RX TX   P1_1  P1_2  和串口屏RX接TX    TX 接RX       波特率115200&lt;/p&gt;
&lt;p&gt;ADC用的是1.4通道。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;LaunchPadMSP430G2553.jpg&quot; alt=&quot;G2&quot;&gt; &lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="嵌入式" scheme="https://huatingzhihoudahao.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
    <category term="msp430g2" scheme="https://huatingzhihoudahao.github.io/blog/tags/msp430g2/"/>
    
    <category term="uart通信" scheme="https://huatingzhihoudahao.github.io/blog/tags/uart%E9%80%9A%E4%BF%A1/"/>
    
    <category term="ADC" scheme="https://huatingzhihoudahao.github.io/blog/tags/ADC/"/>
    
    <category term="UsartGPU" scheme="https://huatingzhihoudahao.github.io/blog/tags/UsartGPU/"/>
    
  </entry>
  
  <entry>
    <title>云端ccs路径配置问题</title>
    <link href="https://huatingzhihoudahao.github.io/blog/2021/05/03/%E4%BA%91%E7%AB%AFccs%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/"/>
    <id>https://huatingzhihoudahao.github.io/blog/2021/05/03/%E4%BA%91%E7%AB%AFccs%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/</id>
    <published>2021-05-03T09:26:40.000Z</published>
    <updated>2021-05-03T19:56:48.103Z</updated>
    
    <content type="html"><![CDATA[<p>云端ccs很方便，直接百度ccs，进去选云端开发就行，虽然不用下CCS会引导下载点和本机串口交互的东西？带有很多库，很爽。想看官方例程直接TI官网随便搜一个搜型号，点进器材贩卖页面， 下面相关的会有430WARE套件可以下。430家所有的都有。开发的时候官网搜data sheet和user guide。</p><p>今天被云端ccs小小的坑了一下。</p><p>云端ccs在建立工程的时候可以选择很多库，比如我选的这个就带有很多adc cpu gpio巴拉巴拉的库，但是报错说打不开这个IEC60730_march_test.h   </p><p><img src="1.jpg" alt="G2"></p><p>正常情况下 工程右键 project properties link的地方选择路径，把.h给include就行。但是ccs没法改。。</p><p>所以只能自己把</p><pre><code>#include &quot;IEC60730_march_test.h&quot;</code></pre><p>改成以工程文件名为根目录   之后的绝对路径  </p><pre><code>#include &quot;IEC60730/include/IEC60730_march_test.h&quot;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;云端ccs很方便，直接百度ccs，进去选云端开发就行，虽然不用下CCS会引导下载点和本机串口交互的东西？带有很多库，很爽。想看官方例程直接TI官网随便搜一个搜型号，点进器材贩卖页面， 下面相关的会有430WARE套件可以下。430家所有的都有。开发的时候官网搜data sh</summary>
      
    
    
    
    <category term="嵌入式开发环境" scheme="https://huatingzhihoudahao.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    
    
    <category term="ccs cloud" scheme="https://huatingzhihoudahao.github.io/blog/tags/ccs-cloud/"/>
    
  </entry>
  
  <entry>
    <title>msp430g2之频率计(Timer_A)</title>
    <link href="https://huatingzhihoudahao.github.io/blog/2021/05/03/msp430g2%E9%A2%91%E7%8E%87%E8%AE%A1/"/>
    <id>https://huatingzhihoudahao.github.io/blog/2021/05/03/msp430g2%E9%A2%91%E7%8E%87%E8%AE%A1/</id>
    <published>2021-05-03T04:34:55.000Z</published>
    <updated>2021-05-03T18:17:02.616Z</updated>
    
    <content type="html"><![CDATA[<p>可以测频率和脉宽，用的Timer_A的捕获模式</p><p>先上pinmap</p><p>g2553有两个的timer_A模块，每一个包括1个16位定时器和3个捕获比较模块（CCRX）。（网上误人子弟把g2通用手册的timerA和timerB截图放上去说2553有timerA和timerB，不要信。要看看底下这个官网的datesheet里的图，而不是看通用的那种用户手册）</p><p><img src="%E6%A8%A1%E5%9D%97.jpg" alt="image-20210503144441840"></p><p><img src="pinmap.jpg" alt="image-20210503144441840"></p><p><img src="image-20210503155430023.png" alt="image-20210503155430023"></p><p>g2553的timer_A模块包括1个16位定时器和3个捕获比较模块（CCRX），定时器就搁那计数就完了，计数值被存放在TAR寄存器。配置就这个</p><p><img src="1.jpg" alt="image-20210503144441840"></p><p> 那边CCRx比较捕获模块，CCR0，CCR1，CCR2性质基本一样，</p><p>在比较的时候用TAR与TACCRx对比，计数到对比一致时对应的CCIFG置位。</p><p>在捕获的时候把TAR存入TACCRx，把对应的CCIFG置位。</p><p>不能同时捕获和比较。配置就这个</p><p><img src="2.jpg" alt="image-20210503174039643"></p><p> TAR与TACCRx就是放数字的16位寄存器</p><p>但是：CCR0是特殊的。 特殊在于：TACCR0 CCIFG 有自己单独的中断向量TACCR0  而且优先级最高。</p><p>而其他的CCIFG(指的是比较捕获模块CCR1 CCR2)和  TAIFG（溢出中断）都用一个中断向量TAIV。想分别是哪个CCIFG还是说TAIFG触发的这个中断，还需要查TAIV(寄存器用户指南371页)，像IO中断那样 （由于有两个定时器所以查的时候是TA0IV这样）</p><p>为什么搞特殊 ，因为CCR0就是用来控制timerA的定时器模块的周期的。</p><p>也就是说整个timerA两大部分，一边是定时器模块一边是比较捕获模块，</p><p>在上数模式下CCR0可以确定定时器模块的周期从0-2000增计数，那就会0-2000，然后0-2000雷打不动的计（虽然最高的65535但是CCR0定了就确定他到CCR0设置的那个点了就会按照设定的增/减/增减模式 走）    </p><p>而CCR1 和CCR2 只是说自己利用这个计数器，到了什么点，比如比较模式就比较计数器记的数有没有到自己要求的那个TACCR1值，到了就自己找个小旗子记一下（即CCIFG1置位。）  </p><p>溢出中断就是定时器模块的溢出中断的，依赖于定时器模块最后的模式。</p><p>就是比如在上数模式下从TACCR0的2000满了，重新到0，这就记一个溢出中断TAIFG</p><p>在连续模式下，计数到65535就溢出，重新到0，这也记一个溢出中断TAIFG。</p><p>比较模式一般用于输出，就计数计到多少翻转电平之类的，用于输出PWM.输出的方式啥的看比较捕获控制寄存器的outmode  （看寄存器手册362页）</p><p>捕获模式捕获的哪一个端口的看CCIS选的是CCIxA还是CCIxB</p><p><img src="3.jpg" alt="image-20210503174039643"></p><p>哪个端口是CCIxA还是CCIxB  看寄存器用户手册会让我们看data sheet 。反正就 要看哪个脚复用成哪个功能就看数据手册，寄存器就看用户手册。不会写代码就看指导书或者官网。</p><p>可以看到TA0 的CCI0A在P1.1    CCI1A在P1.2  其他的看data sheet把 今天就用这个CCR1比较捕获模块的A口，即P1.2。想复用的话，P1SEL的BIT2要置1，P1SEL2的不能置1.</p><p>总结一遍：G2553有两个定时器即为timer0_A和timer1_A，每一个由一个定时器模块(溢出中断TAIFG)   和  三个比较捕获模块(CCR0，CCR1，CCR2组成，其中CCR0在非连续模式下用来设置定时器模块的周期)。</p><p>板载资源用了timer0的CCR1的CCI1A   即TA0.1的 A口    P1.2</p><p>下面这个代码是65535默认周期，CCR1捕获，连续计数上升沿捕获。方法图如下</p><p><img src="%E5%9B%BE.jpg" alt="G2">  </p><pre><code class="c">#include &lt;msp430.h&gt; unsigned int temp1=0,temp2=0,temp3=0,temp4=0;time1=0,time2=0,time3=0,time4=0;unsigned int cap_flag=0;int overflow=0;long hz=0,maikuan=0;int main(void)&#123;    WDTCTL = WDTPW | WDTHOLD;    // Stop watchdog timer    BCSCTL1 = CALBC1_16MHZ;    DCOCTL = CALDCO_16MHZ;    //P1.2           通用型数字 I/O 引脚    //TA0.1            Timer0_A，捕捉：CCI1A 输入，比较：Out1 输出  P1SEL|=BIT2;//1.2开第二功能，没有动P1SEL2，P1SEL2也置1那就复用成uart模式了  P1DIR&amp;=~BIT2;//1.2设为读  TA0CTL|=TASSEL_2+MC_2+ TACLR+TAIE;  //smclk 16Mhz,不分频,连续计数,置位，开溢出中断  TA0CCTL1|=CM_1+CCIE+CAP+CCIS_0;//上升沿捕获，捕获使能  _EINT();  while(1);&#125;#pragma vector=TIMER0_A1_VECTOR//  响应CCR1的CCIFG CCR2的CCIFG 和溢出中断TAIFG__interrupt void Timer0_A1(void)&#123;     switch( TA0IV ) //查TAIV看是哪个中断响应    &#123; case 2:              cap_flag++; //CCR1的CCIFG              if(cap_flag==1)//第一次检测的是上升沿              &#123; overflow=0;                TA0CCTL1&amp;=~CM_1;                TA0CCTL1|=CM_2;//改成下降沿捕获                TA0CTL|= TACLR; //清定时器              &#125;              if(cap_flag==2)//这次捕获的是下降沿              &#123;  temp1=TA0CCR1;                 time1=overflow;                 TA0CCTL1&amp;=~CM_2;                 TA0CCTL1|=CM_1;//改成上升沿捕获              &#125;              if(cap_flag==3)//这次是上升沿捕获              &#123;                temp2=TA0CCR1;                time2=overflow;                hz=16000000/(time2*65536+temp2); //第二次计数的ccr1会经过可能一些周期，所以记得overflow*65536                maikuan=((time1*65536+temp1)*100)/(time2*65536+temp2);                cap_flag=0;              &#125;              break;     case 4:              break;     case 10: overflow++;//溢出中断的TAIFG,溢出一次加1          break;     &#125;&#125;//这里遇到了一个问题，就是配置CCTL|=CM_1之后，想要改为CM_2,要先&amp;=~CM_1，再|=CM_2//不然先|=CM_1,和010000……或    再|=CM_2,和10000……或，合起来就是11000……，也就是配置成了CM_3上下沿都捕获</code></pre><p>效果如图，输入是占空比30%，频率900hz的矩形波</p><p><img src="%E6%95%88%E6%9E%9C.jpg" alt="G2"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;可以测频率和脉宽，用的Timer_A的捕获模式&lt;/p&gt;
&lt;p&gt;先上pinmap&lt;/p&gt;
&lt;p&gt;g2553有两个的timer_A模块，每一个包括1个16位定时器和3个捕获比较模块（CCRX）。（网上误人子弟把g2通用手册的timerA和timerB截图放上去说2553有tim</summary>
      
    
    
    
    <category term="嵌入式" scheme="https://huatingzhihoudahao.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
    <category term="ccs" scheme="https://huatingzhihoudahao.github.io/blog/tags/ccs/"/>
    
    <category term="msp430g2" scheme="https://huatingzhihoudahao.github.io/blog/tags/msp430g2/"/>
    
    <category term="Timer_A中断" scheme="https://huatingzhihoudahao.github.io/blog/tags/Timer-A%E4%B8%AD%E6%96%AD/"/>
    
    <category term="捕获" scheme="https://huatingzhihoudahao.github.io/blog/tags/%E6%8D%95%E8%8E%B7/"/>
    
  </entry>
  
  <entry>
    <title>msp430g2之IO和其外部中断(GPIO  IO外部中断)</title>
    <link href="https://huatingzhihoudahao.github.io/blog/2021/05/03/msp430g2%E4%B9%8BIO%E5%92%8C%E5%85%B6IO%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/"/>
    <id>https://huatingzhihoudahao.github.io/blog/2021/05/03/msp430g2%E4%B9%8BIO%E5%92%8C%E5%85%B6IO%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/</id>
    <published>2021-05-02T18:59:55.000Z</published>
    <updated>2021-05-03T18:14:26.691Z</updated>
    
    <content type="html"><![CDATA[<p>本次开发用云端ccs开发，结合launchpad指导手册（教程）和g2用户手册（看寄存器）食用</p><p>板载资源就用了一个灯P1_0的red_led，时钟源全部默认</p><p><img src="LaunchPadMSP430G2553.jpg" alt="G2"></p><h2 id="msp家的所有例程上ti官网找mspware-https-dev-ti-com-tirex-explore-啥都有-直接云端开发就行。"><a href="#msp家的所有例程上ti官网找mspware-https-dev-ti-com-tirex-explore-啥都有-直接云端开发就行。" class="headerlink" title="msp家的所有例程上ti官网找mspware   https://dev.ti.com/tirex/explore/    啥都有   直接云端开发就行。"></a>msp家的所有例程上ti官网找mspware   <a href="https://dev.ti.com/tirex/explore/">https://dev.ti.com/tirex/explore/</a>    啥都有   直接云端开发就行。</h2><h3 id="先从点亮一个led灯开始吧。。。"><a href="#先从点亮一个led灯开始吧。。。" class="headerlink" title="先从点亮一个led灯开始吧。。。"></a>先从点亮一个led灯开始吧。。。</h3><p>读写IO都需要设置PxDIR 高电平输出（往外写）   低电平输入（往内读）</p><p>CPU读IO，实际上是读PxIN寄存器。</p><p>CPU写IO，实际是写PxOUT寄存器。</p><p>g2寄存器一般是八位，平时要么用十六进制表示八位  0x01  每位自己设</p><p>要么用P1DIR |= BIT0;   BIT0是00000001，|=是按位或，有1则1，这些的话最后一位会被置1 其他不变。</p><p>提示：作为高阻输入IO时，务必关掉内部上下拉电阻开关PxREN，否则输入就不是高阻态了。（悬空就是高阻态，至于为什么要上下拉我也不知道了，建议看指导手册IO结构图）</p><pre><code class="C">#include &lt;msp430.h&gt;int main(void)&#123;    volatile unsigned int i;                  //volatile是一个特征修饰符（type specifier）.volatile的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值。    WDTCTL = WDTPW + WDTHOLD;                 // Stop watchdog timer    P1DIR |= 0x01;                            // Set P1.0 to output direction  看引脚图可以看到是1_0是红灯    while(1)    &#123;        P1OUT ^= 0x01;                        // Toggle P1.0 using exclusive-OR     和00000001异或      //  P1OUT =~P1OUT;   //位操作取反        for (i=10000; i&gt;0; i--);  &#125;&#125;</code></pre><h3 id="然后做IO外部中断"><a href="#然后做IO外部中断" class="headerlink" title="然后做IO外部中断"></a>然后做IO外部中断</h3><p>用的是P1_3 push2 的外部中断</p><p><img src="LaunchPadMSP430G2553.jpg" alt="G2"></p><p><img src="1.jpg" alt="G2"></p><p><img src="2.png" alt="G2"></p><p><img src="3.jpg" alt="G2"></p><p>g2有P1P2两列外部IO中断,需要用PXIE对IO中断使能，IES设置上下边沿触发，REN设置上拉下拉</p><p>&amp;= ~是置0，进入中断之后，中断标志位会自动置1，需要PXIFG=0手动清成0.（有的会做成硬件清0，但是如果懒得查它到底自动不自动，还是直接软件清零吧）</p><p>中断向量是vector=PORT1_VECTOR    </p><pre><code class="c">#include &lt;msp430.h&gt;int main(void)&#123;  WDTCTL = WDTPW + WDTHOLD;                 // Stop watchdog timer  P1DIR |= BIT0;                            // Set P1.0 to output direction  P1IE |=  BIT3;                            // P1.3 interrupt enabled  P1IES |= BIT3;                            // P1.3 Hi/lo edge  P1REN |= BIT3;                            // Enable Pull Up on SW2 (P1.3)  P1IFG &amp;= ~BIT3;                           // P1.3 IFG cleared                                                            //BIT3 on Port 1 can be used as Switch2                                              __bis_SR_register(LPM4_bits + GIE);       // Enter LPM4 w/interrupt  //把SR寄存器的GIE位置位，也可以用_enable_interrupts();  即总中断使能   //LPM4是low power node4 直接进入低功耗模式，会被中断唤醒然后接着睡&#125;/*// Port 1 interrupt service routine#if defined(__TI_COMPILER_VERSION__) || defined(__IAR_SYSTEMS_ICC__)#pragma vector=PORT1_VECTOR//这个是给中断向量表进行赋值的__interrupt void Port_1(void)//关键字__interrupt则表示这个函数是中断服务函数这种特殊函数。#elif defined(__GNUC__) //这玩意是gcc主版本号，安装gcc了都能过预编译void __attribute__ ((interrupt(PORT1_VECTOR))) Port_1 (void)//GNU C 的一大特色就是__attribute__ 机制。attribute 可以设置函数属性（Function Attribute）、变量属性（Variable Attribute）和类型属性（Type Attribute）。这里是设置Port_1函数为PORT1_VECTOR的中断向量#else#error Compiler not supported!#endif&#123;  P1OUT ^= BIT0;                            // P1.0 = toggle  P1IFG &amp;= ~BIT3;                           // P1.3 IFG cleared&#125;*///其实大家可以不用这么写,这么写就行。#pragma vector=PORT1_VECTOR__interrupt void Port_1(void)&#123;  P1OUT ^= BIT0;                            // P1.0 = toggle  P1IFG &amp;= ~BIT3;                           // P1.3 IFG cleared&#125;</code></pre><p><img src="4.jpg" alt="G2"></p><p>P1八个IO共用这一个中断，如果想要辨别是哪个端口出的低电平，就用IFG来判断，IFG进入中断就硬件置1了。</p><p>用((P1IN&amp;Push_Key)==0)    来确保此刻是按下的，即P1那个导致进入中断的端口还处于低电平还没有恢复原状。</p><pre><code class="c">voidP1_IODect()&#123;unsigned int Push_Key=0;Push_Key=P1IFG&amp;(~P1DIR);//代码1：检测所有输入IO，确保只有1个IO中断被“记录”//----延时一段时间，避开机械抖动区域------__delay_cycles(10000);//代码2：消灭下降沿2、3、5//----判断按键状态是否与延时前一致------if((P1IN&amp;Push_Key)==0) //代码3：专门消灭下降沿4&#123;//----判断具体哪个IO被按下，调用该IO的事件处理函数    switch(Push_Key)//代码4：不用P1IN来判断，以确保有且只有1按键响应    &#123;        case BIT0: P10_Onclick();break;        case BIT1: P11_Onclick();break;        case BIT2: P12_Onclick();break;        case BIT3: P13_Onclick();break;        case BIT4: P14_Onclick();break;        case BIT5: P15_Onclick();break;        case BIT6: P16_Onclick();break;        case BIT7: P17_Onclick();break;        default:break;    &#125;&#125;</code></pre><p>P1x_Onclick()自己定义。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本次开发用云端ccs开发，结合launchpad指导手册（教程）和g2用户手册（看寄存器）食用&lt;/p&gt;
&lt;p&gt;板载资源就用了一个灯P1_0的red_led，时钟源全部默认&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;LaunchPadMSP430G2553.jpg&quot; alt=&quot;G2&quot;</summary>
      
    
    
    
    <category term="嵌入式" scheme="https://huatingzhihoudahao.github.io/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
    <category term="ccs" scheme="https://huatingzhihoudahao.github.io/blog/tags/ccs/"/>
    
    <category term="IO外部中断" scheme="https://huatingzhihoudahao.github.io/blog/tags/IO%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/"/>
    
    <category term="msp430g2" scheme="https://huatingzhihoudahao.github.io/blog/tags/msp430g2/"/>
    
    <category term="GPIO" scheme="https://huatingzhihoudahao.github.io/blog/tags/GPIO/"/>
    
  </entry>
  
  <entry>
    <title>鉴于我的bug体质这里可能有你需要的大部分hexo主题相关解决方案</title>
    <link href="https://huatingzhihoudahao.github.io/blog/2021/04/30/bug%20in%20first%20blog/"/>
    <id>https://huatingzhihoudahao.github.io/blog/2021/04/30/bug%20in%20first%20blog/</id>
    <published>2021-04-30T15:34:15.420Z</published>
    <updated>2021-05-02T17:02:06.054Z</updated>
    
    <content type="html"><![CDATA[<p>BUG</p><h2 id="tips-改完得hexo-clean-g-d-来一趟上传上去（如果搞完了还是没好，可能是网太烂，换一个网8）-如果改了module的js之类的，务必要clean！！！"><a href="#tips-改完得hexo-clean-g-d-来一趟上传上去（如果搞完了还是没好，可能是网太烂，换一个网8）-如果改了module的js之类的，务必要clean！！！" class="headerlink" title="tips.改完得hexo clean g d 来一趟上传上去（如果搞完了还是没好，可能是网太烂，换一个网8）    如果改了module的js之类的，务必要clean！！！"></a><em>tips.改完得hexo clean g d 来一趟上传上去（如果搞完了还是没好，可能是网太烂，换一个网8）    如果改了module的js之类的，务必要clean！！！</em></h2><h2 id="1-本地显示正常，上传的网站css渲染不出来or一片空白"><a href="#1-本地显示正常，上传的网站css渲染不出来or一片空白" class="headerlink" title="1.本地显示正常，上传的网站css渲染不出来or一片空白"></a>1.本地显示正常，上传的网站css渲染不出来or一片空白</h2><p>改_config,     url: https://用户名.github.io/rep名    root:/rep名/    </p><pre><code>url: https://huatingzhihoudahao.github.io/blog/root: /blog/</code></pre><p>然后自己的网站名就成了<a href="https://huatingzhihoudahao.github.io/blog/">https://huatingzhihoudahao.github.io/blog/</a></p><p>我是从后面9来的，插图片更换插件代码，没能成功，改了url为<a href="https://huatingzhihoudahao.github.io才成功../">https://huatingzhihoudahao.github.io才成功。。</a></p><h2 id="2-文件在上传的网站上无显示"><a href="#2-文件在上传的网站上无显示" class="headerlink" title="2.文件在上传的网站上无显示"></a>2.文件在上传的网站上无显示</h2><p>注意的deploy的branch和github pages的是否一致，一开始我用的master，github的仓库里倒是有了，但是网站显示的是gh。</p><pre><code>branch: gh-pages</code></pre><p>以及注意主题选的啥玩意。。。（我选的是github pages推的merlot，是个 jekyll 的主题。。根本不是hexo的，由于那个主题实在是好看我又跑去搭jekyll，结果有个什么玩意又要0.3.6的又要0.4.0的没整好，不了了之。。换回hexo了，hexo还是简单点…）</p><h2 id="3-换主题之后上传的网站一片空白"><a href="#3-换主题之后上传的网站一片空白" class="headerlink" title="3.换主题之后上传的网站一片空白"></a>3.换主题之后上传的网站一片空白</h2><p>看自己主题的作者的md，以及issue (我下的是据作者说有lofter那味儿的snark，有个搜索功能，需要自己在yml里添加一下)</p><pre><code>search:    path: search.xml    field: post</code></pre><h2 id="4-上传网站主题的头像是本地图片，然而显示不出来"><a href="#4-上传网站主题的头像是本地图片，然而显示不出来" class="headerlink" title="4.上传网站主题的头像是本地图片，然而显示不出来"></a>4.上传网站主题的头像是本地图片，然而显示不出来</h2><p>这招是乐哥教的，按住fn 和f12，查看源码，点左上角第一个的框框，即选中一个元素进行检查，然后点到没出来的图片上，可以看到对应的代码位置。我的是这个</p><pre><code>&lt;img class=&quot;nofancybox&quot; src=&quot;/img/profile.jpg&quot; width=&quot;128&quot; height=&quot;128&quot;&gt;</code></pre><p>把斜杠去掉，（本地好像是得加一个空格）   </p><pre><code>&lt;img class=&quot;nofancybox&quot; src=&quot;img/profile.jpg&quot; width=&quot;128&quot; height=&quot;128&quot;&gt;</code></pre><p>不过这些改了没用，只是当前页面有用，再打开一回还是原来那样，所以去改主题源码吧，一般在主题的layout 的_partial底下，挺多的，抽奖找文件吧？我的是在nav-menu，斜杠删了就行</p><pre><code>        a(class=&quot;hdimg img&quot; href=&quot;/&quot;)            img(src=&quot;img/profile.jpg&quot; class=&quot;nofancybox&quot; width=&quot;128&quot; height=&quot;128&quot;)        h1.ttl            a(href=&quot;/&quot;)= config.title</code></pre><p>src=”img/profile.jpg” 这种路径貌似系统可以自动补<a href="https://huatingzhihoubalabalabala之类的前缀？">https://huatingzhihoubalabalabala之类的前缀？</a></p><h2 id="5-上传网站主题的background-png加载不出来"><a href="#5-上传网站主题的background-png加载不出来" class="headerlink" title="5.上传网站主题的background.png加载不出来"></a>5.上传网站主题的background.png加载不出来</h2><p>同4理，看控制台 ，底下有几个error 锁定一下， 我的在style.scss，感觉把路径改对就行，我改的是绝对路径（记得改源码里的）</p><pre><code>body &#123;  background-image: url(https://github.com/huatingzhihoudahao/blog/blob/gh-pages/img/backgroud.png);</code></pre><p>其实我的显示不出来也看不出来，因为默认就是藏蓝色，本来想换成米斯达的，但是好像这样和头像更搭一点。</p><p>淦，跨源读取阻止(CORB)功能阻止了 MIME 类型为 text/html 的跨源响应。。。。</p><p>我发现我当时截的url咋莫名其妙带了个blob，于是返回了上一级，然后拼起来，用了这个</p><pre><code>    background-image: url(https://github.com/huatingzhihoudahao/blog/tree/gh-pages/img/backgroud.png);</code></pre><p>nice~ 好使了 没报错了   </p><p>(我是后面来的 这里好了个锤子，github.com和huatingzhoudahao.github.io （这是不放域名只放图片的时候，终端显示的读取路径） 算是主域名不同？ 貌似是跨域的，我点开这个io，就是在这个io的html下，然后又设定去<a href="https://github.com/huatingzhihoudahaobalabala%E8%BF%99%E8%BE%B9%E5%8F%96%EF%BC%8C%E5%BA%94%E8%AF%A5%E5%B0%B1%E6%98%AF%E8%B7%A8%E5%9F%9F%E5%90%A7%E3%80%82%E8%B7%A8%E5%9F%9F%E6%8C%87%E7%9A%84%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8D%E8%83%BD%E6%89%A7%E8%A1%8C%E5%85%B6%E4%BB%96%E7%BD%91%E7%AB%99%E7%9A%84%E8%84%9A%E6%9C%AC%E3%80%82%E5%AE%83%E6%98%AF%E7%94%B1%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E9%80%A0%E6%88%90%E7%9A%84%EF%BC%8C%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E6%96%BD%E5%8A%A0%E7%9A%84%E5%AE%89%E5%85%A8%E9%99%90%E5%88%B6%E3%80%82%E6%89%80%E8%B0%93%E5%90%8C%E6%BA%90%E6%98%AF%E6%8C%87%EF%BC%8C%E5%9F%9F%E5%90%8D%EF%BC%8C%E5%8D%8F%E8%AE%AE%EF%BC%8C%E7%AB%AF%E5%8F%A3%E5%9D%87%E7%9B%B8%E5%90%8C)%E3%80%82">https://github.com/huatingzhihoudahaobalabala这边取，应该就是跨域吧。跨域指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器施加的安全限制。所谓同源是指，域名，协议，端口均相同)。</a>     至于关于blob什么意思为什么会出现加不加有无影响就没研究了，反正加不加都说我跨源。</p><p>举例</p><pre><code>http://www.123.com/index.html 调用 http://www.123.com/server.php （非跨域）http://www.123.com/index.html 调用 http://www.456.com/server.php （主域名不同:123/456，跨域）http://abc.123.com/index.html 调用 http://def.123.com/server.php （子域名不同:abc/def，跨域）http://www.123.com:8080/index.html 调用 http://www.123.com:8081/server.php （端口不同:8080/8081，跨域）http://www.123.com/index.html 调用 https://www.123.com/server.php （协议不同:http/https，跨域）请注意：localhost和127.0.0.1虽然都指向本机，但也属于跨域。————————————————版权声明：本文为CSDN博主「ouxiaoxian」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/ouxiaoxian/article/details/89332027</code></pre><p>这个我已经不管了。。。就这样吧懒得改了。。反正看不出有问题。。</p><p>现在的我是从第六个问题来的！！解决了！！</p><pre><code> background-image: url(https://huatingzhihoudahao.github.io/blog/img/backgroud.png);</code></pre><p>我实在是太蠢了。。。。。</p><h2 id="6-上传网站主题的头像，主页面显示出来了，点进博客里面就显示不出来"><a href="#6-上传网站主题的头像，主页面显示出来了，点进博客里面就显示不出来" class="headerlink" title="6.上传网站主题的头像，主页面显示出来了，点进博客里面就显示不出来"></a>6.上传网站主题的头像，主页面显示出来了，点进博客里面就显示不出来</h2><p>同4，5理由，控制台锁定error，发现图片位置是</p><pre><code>https://huatingzhihoudahao.github.io/blog/2021/04/30/hello-world/img/profile.jpg</code></pre><p>打开确实是没有的，我在想底下是最后生成的index.html</p><pre><code>&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/blog/js/ready.js&quot; async&gt;&lt;/script&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css&quot;&gt;&lt;body class=&quot;night&quot;&gt;&lt;div class=&quot;mobile-head&quot; id=&quot;mobile-head&quot;&gt;&lt;div class=&quot;navbar-icon&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;navbar-title&quot;&gt;&lt;a href=&quot;/&quot;&gt;LITREILY&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;navbar-search&quot;&gt;&lt;!--= show a circle here--&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;h-wrapper&quot; id=&quot;menu&quot;&gt;&lt;nav class=&quot;h-head box&quot;&gt;&lt;div class=&quot;m-hdimg&quot;&gt;&lt;a class=&quot;hdimg img&quot; href=&quot;/&quot;&gt;&lt;img class=&quot;nofancybox&quot; src=&quot;img/profile.jpg&quot;</code></pre><p>在控制台报错是GET <a href="https://huatingzhihoudahao.github.io/blog/2021/04/30/hello-world/img/profile.jpg">https://huatingzhihoudahao.github.io/blog/2021/04/30/hello-world/img/profile.jpg</a> 404      或许是因为src=”img/profile.jpg”的写法是相对路径？，</p><p>于是我把</p><pre><code>&lt;img class=&quot;nofancybox&quot; src=&quot;/img/profile.jpg&quot; width=&quot;128&quot; height=&quot;128&quot;&gt;</code></pre><p>改成</p><pre><code>img(src=&quot;https://github.com/huatingzhihoudahao/blog/tree/gh-pages/img/profile.jpg&quot;</code></pre><p>失败了。。控制台虽然没错误了，但是根本没显示出来，而且控制台报了5以及和5一样的错。。。阻止跨源响应。。。。让我怀疑我的5是不是自己看错了其实根本没解决。。</p><pre><code>跨源读取阻止(CORB)功能阻止了 MIME 类型为 text/html 的跨源响应 https://github.com/huatingzhihoudahao/blog/blob/gh-pages/img/profile.jpg。有关详细信息，请参阅 https://www.chromestatus.com/feature/5629709824032768。style.css:1 跨源读取阻止(CORB)功能阻止了 MIME 类型为 text/html 的跨源响应 https://github.com/huatingzhihoudahao/blog/blob/gh-pages/img/backgroud.png。有关详细信息，请参阅 https://www.chromestatus.com/feature/562970982403278</code></pre><p>我改成</p><pre><code> img(src=&quot;Access-Control-Allow-Origin:https://github.com/huatingzhihoudahao/blog/tree/gh-pages/img/profile.jpg&quot;</code></pre><p>也不行，说我</p><pre><code>Failed to load resource: net::ERR_UNKNOWN_URL_SCHEME</code></pre><p>估计是写法有问题，改成</p><pre><code>img(src=&quot;Access-Control-Allow-Origin:github.com/huatingzhihoudahao/blog/tree/gh-pages/img/profile.jpg&quot;</code></pre><p>一样的net::ERR_UNKNOWN_URL_SCHEME.于是加了个标签</p><pre><code>img(crossOrigin=&quot;Anonymous&quot; </code></pre><p>还是不行。。</p><p>我又全部退回去，返回到一开始的删掉斜杠</p><pre><code>&lt;img class=&quot;nofancybox&quot; src=&quot;img/profile.jpg&quot; width=&quot;128&quot; height=&quot;128&quot;&gt;</code></pre><p>img的src规则是这样的，如果是<a href="http://balablabal/img/xxx.jpg">http://balablabal/img/xxx.jpg</a>  这种系统是不会做什么的 读就直接读的这个url</p><p>但如果写img/profile.jpg，他就会默认把前面补上 当前页面的头 比如<a href="https://huatingzhihoudahao.github.io/blog/archives/img/profile.jpg">https://huatingzhihoudahao.github.io/blog/archives/img/profile.jpg</a>  补成这个样子（这个是我点击归档出来的路径）  是没有的 所以会显示不出来</p><p>如果是主页面,会补成这个样子<a href="https://huatingzhihoudahao.github.io/blog/img/profile.jpg">https://huatingzhihoudahao.github.io/blog/img/profile.jpg</a>   ，是有的，所以可以显示。如果是归档啊 关于啊 之类的 可以自己在本地搭建hexo的地方（比如我是在myblog部署的git）找source，找about啊归档啊标签啊之类的（hexo new 出来的文件夹） ，在里面新建一个img文件夹把图片扔进去。上传之后 可以保证在io上点进归档是可以显示头像的。但是md文档的点进去出不了头像怎么解决还不知道。</p><p>!!!我知道怎么解决这些问题了！！统统用<a href="https://huatingzhihoudahao.github.io/blog/img/profile.jpg%EF%BC%81%EF%BC%81">https://huatingzhihoudahao.github.io/blog/img/profile.jpg！！</a> 为什么我想绝对路径的时候只想到到github.com/balaba那个地方呢！直接io/balabala  不就行了！</p><p>n！i！c！e！！！（虽然之前的我实在是太傻了。。。怎么就脑子没转过弯来）</p><h2 id="7-根据主题作者提示安装npm-install-hexo-renderer-pug-–save的问题"><a href="#7-根据主题作者提示安装npm-install-hexo-renderer-pug-–save的问题" class="headerlink" title="7.根据主题作者提示安装npm install hexo-renderer-pug –save的问题"></a>7.根据主题作者提示安装npm install hexo-renderer-pug –save的问题</h2><h4 id="7-1出现18-packages-are-looking-for-funding-run-npm-fund-for-details"><a href="#7-1出现18-packages-are-looking-for-funding-run-npm-fund-for-details" class="headerlink" title="7.1出现18 packages are looking for funding   run npm fund for details"></a>7.1出现18 packages are looking for funding   run <code>npm fund</code> for details</h4><p>其实就是求打赏啦，可以run npm fund看链接点击去打赏，不想打赏就</p><pre><code>npm install hexo-renderer-pug --save --no-fund</code></pre><h4 id="7-2出现found-1-high-severity-vulnerability：-run-npm-audit-fix-to-fix-them-or-npm-audit-for-details"><a href="#7-2出现found-1-high-severity-vulnerability：-run-npm-audit-fix-to-fix-them-or-npm-audit-for-details" class="headerlink" title="7.2出现found 1 high severity vulnerability： run npm audit fix to fix them, or npm audit for details"></a>7.2出现found 1 high severity vulnerability： run <code>npm audit fix</code> to fix them, or <code>npm audit</code> for details</h4><p>在431扫描包中找到1个高度严重性漏洞1漏洞需要手动审查。有关详细信息，请参阅完整报告。</p><pre><code>npm audit --json</code></pre><p>查看详细报告</p><pre><code> &quot;overview&quot;: &quot;### Impact\n\nIn affected versions of `pug` and `pug-code-gen`, if a remote attacker was able to control the `pretty` option of the pug compiler, e.g. if you spread a user provided object such as the query parameters of a request into the pug template inputs, it was possible for them to achieve remote code execution on the node.js backend.\n\n### Patches\n\nUpgrade to `pug@3.0.1` or `pug-code-gen@3.0.2` or `pug-code-gen@2.0.3`, which correctly sanitise the parameter.\n\n### Workarounds\n\nIf there is no way for un-trusted input to be passed to pug as the `pretty` option, e.g. if you compile templates in advance before applying user input to them, you do not need to upgrade.&quot;,      &quot;recommendation&quot;: &quot;Upgrade `pug` to version 3.0.1&quot;,      &quot;references&quot;: &quot;- [GitHub Advisory](https://github.com/advisories/GHSA-p493-635q-r6gr)\n- [CVE](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-21353)\n- [Similar advisory for `pug-code-gen`](https://www.npmjs.com/advisories/1644)&quot;,</code></pre><p>是pug要升级（直接npm audit fix –force没用会说要手动升级）所以去references网站下载。。</p><p>网站让我直接npm install pug   版本是3.0.2   但是最后还是给我报高危漏洞要升级。。</p><p>不管了。。。。</p><p>因为我发现照着作者说的插件安了一通之后 好像没有报search xml之类的错了 </p><p>以及发现有人说npm安装的时候用cmd安装，，我用的是git bash。然而都一样都会报这个问题</p><h2 id="8-点击头像或者about之类的不能像原主题显示的那样跳转到主页面而是404"><a href="#8-点击头像或者about之类的不能像原主题显示的那样跳转到主页面而是404" class="headerlink" title="8.点击头像或者about之类的不能像原主题显示的那样跳转到主页面而是404"></a>8.点击头像或者about之类的不能像原主题显示的那样跳转到主页面而是404</h2><p>我的正确打开路径是<a href="https://huatingzhihoudahao.github.io/blog/archives/">https://huatingzhihoudahao.github.io/blog/archives/</a></p><p>点击归档之类的标签就是<a href="https://huatingzhihoudahao.github.io/blog/archives/">https://huatingzhihoudahao.github.io/blog/archives/</a></p><p>点击头像就是<a href="https://huatingzhihoudahao.github.io/blog/%E6%98%AF404">https://huatingzhihoudahao.github.io/blog/是404</a></p><p>乐哥应该在js的脚本里设的？我找了一圈没找到。之后又用4，5的方法，找到了是 a href=“  ”这类的东西，前面会被自动加上<a href="https://huatingzhihoudahao.github.io比如我写a/">https://huatingzhihoudahao.github.io比如我写a</a> href=“/blog/tags/“,就会跳转到<a href="https://huatingzhihoudahao.github.io/blog/tags/">https://huatingzhihoudahao.github.io/blog/tags/</a></p><p>于是我到nav-menu的文件里把</p><pre><code>a(class=&quot;hdimg img&quot; href=&quot;/&quot;)  和 a(href=&quot;/&quot;)= config.title</code></pre><p>改成</p><pre><code>  a(class=&quot;hdimg img&quot; href=&quot;/blog/&quot;) 和  a(href=&quot;/blog/&quot;)= config.title</code></pre><p>成功</p><p>至于about和分类或者tags点进去空的，然后对应的url又不像是错的</p><p>点进去404会告诉我</p><pre><code>If this is your site, make sure that the filename case matches the URL.For root URLs (like http://example.com/) you must provide an index.html file.</code></pre><p>那是因为根本没有hexo new，以及没有hexo d  github上就没有index.html  所以new一下上传就行</p><pre><code>hexo new page tags</code></pre><h2 id="9-插图片到文本的问题"><a href="#9-插图片到文本的问题" class="headerlink" title="9.插图片到文本的问题"></a>9.插图片到文本的问题</h2><p><a href="https://www.jianshu.com/p/f72aaad7b852">https://www.jianshu.com/p/f72aaad7b852</a></p><p><a href="https://blog.csdn.net/xjm850552586/article/details/84101345">https://blog.csdn.net/xjm850552586/article/details/84101345</a></p><p>我是5/2的我，我又回来了，这玩意解析的路径在about是对的，在post那解析的不对。。应该解析成2021/4/30balabalba它解析的是.io   欺负我不会js呗。</p><p>我看了源码和网络改进版，他们一个能出about的一个能出post的</p><p><a href="https://blog.csdn.net/xjm850552586/article/details/84101345">https://blog.csdn.net/xjm850552586/article/details/84101345</a></p><p>这个不能给about加index前缀</p><p>原版的about可以加 但是post的解析不对</p><p>这是逼着我读js啊</p><p>改成这样就好了</p><pre><code>var version = String(hexo.version).split(&#39;.&#39;);hexo.extend.filter.register(&#39;after_post_render&#39;, function(data)&#123;  var config = hexo.config;  if(config.post_asset_folder)&#123;        var link = data.permalink;    if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3)       var beginPos = getPosition(link, &#39;/&#39;, 1) + 1;    else       var beginPos = getPosition(link, &#39;/&#39;, 3) + 1;    var appendLink = &#39;&#39;;    // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.    // if not with index.html endpos = link.lastIndexOf(&#39;.&#39;) + 1 support hexo-abbrlink    if(/.*\/index\.html$/.test(link)) &#123;      // when permalink is end with index.html, for example 2019/02/20/xxtitle/index.html      // image in xxtitle/ will go to xxtitle/index/      appendLink = &#39;index/&#39;;      var endPos = link.lastIndexOf(&#39;/&#39;);    &#125;    else &#123;      var endPos = link.lastIndexOf(&#39;/&#39;) + 1;    &#125;    link = link.substring(beginPos, endPos) + &#39;/&#39; + appendLink;</code></pre><p>我是从13回来的我，这个要求config的url不带root的blog  但是这样的话 转载注明出处那里（author）会点不带root的blog的url去 也就是404了，所以为了把转载注明出处那里不搞成404，我把url改了，于是图片显示就都有问题了。也不记得具体哪行代码导致问题。。反正直接删了config.root那一项不好使。具体看13吧。。（代码都是hexo-asset-image插件里的js）</p><h2 id="10-主题段落间距和主页面标题高度显示行数的问题"><a href="#10-主题段落间距和主页面标题高度显示行数的问题" class="headerlink" title="10.主题段落间距和主页面标题高度显示行数的问题"></a>10.主题段落间距和主页面标题高度显示行数的问题</h2><p>控制台看元素，在样式里勾选和不勾选以及更改代码，可以看到效果，一般标的有源码 ，我的在style.css。下面这个是段落间距</p><pre><code>.p-content &#123;    h2,h3,h4 &#123;       // margin: 1.6em 0 0.6em;       margin: 6em 0 0.6em;</code></pre><p>max-width是页面文章标题的宽度</p><pre><code>.p-desc &#123;    position: relative;    top: 0;    left: $art-left-offset;    width: 100%;    max-width: 1000px;</code></pre><p>  font-size: 是在页面文章标题显示的字体大小</p><pre><code>h1 &#123;  font-size: 20px;  line-height: 1.2;  margin: 0 0 36px;  &#125;</code></pre><p>下面这个是显示行数</p><pre><code>.p-desc &#123;    position: relative;    top: 0;    left: $art-left-offset;    width: 100%;    max-width: $art-width;    text-align: left;    padding: $art-padding;    margin-bottom: 20px;    background: $dark-float;    box-shadow: 0 0 40px rgba(0,0,0,0.5);    display: -webkit-box;    -webkit-line-clamp: 1;    -webkit-box-orient: vertical;    overflow: hidden&#125;.l-post  article.p-art &#123;    position: relative;    top: 0;    left: $art-left-offset;    width: 100%;    max-width: $art-width;    text-align: left;    padding: $art-padding;    margin-bottom: 20px;    background: $dark-float;    box-shadow: 0 0 40px rgba(0,0,0,0.5);&#125;</code></pre><p>具体看我的回答<a href="https://www.zhihu.com/question/51632133/answer/1864334646">https://www.zhihu.com/question/51632133/answer/1864334646</a></p><h2 id="12-网页吸色"><a href="#12-网页吸色" class="headerlink" title="12.网页吸色"></a>12.网页吸色</h2><p>控制台太方便了！！以后看到好看的颜色直接开控制台在找代码吸色！在#前面有框框可以打开</p><pre><code> color: #b9549d; </code></pre><h2 id="13-为了调img显示开始现学js"><a href="#13-为了调img显示开始现学js" class="headerlink" title="13.为了调img显示开始现学js.."></a>13.为了调img显示开始现学js..</h2><p>不管怎么样 反正这个在我url不带blog root是blog的情况下  终于可以既在about里显示又在post的md里显示了。。。。我吐了。。。我这个写法就是</p><p> 默认的没改动过的src是xxx.jpg</p><p>后来把src赋值成index+src（index   就是appendLink 就是’index/‘;）  </p><p>如果当前页面是about（即下面有index文件夹且有index.xml）  就在src前面赋一个’index/‘；</p><p>这样src就是’index/xxx.jpg’               前面没有/   这种是相对路径 会被网页自动添加当前页面头</p><p>也就是会被添加成我们想要的locahost:4000  /blog/about/  + index+xx.jpg</p><p>如果src是 ‘/index/xxx.jpg’,</p><p>就不会被添加，只会结合locahost:4000  成  locahost:4000  /index+xx.jpg</p><p>如果src是about/index/xxx.jpg   </p><p>就会被添加结合成locahost:4000 /blog/about/  + about/index+xx.jpg</p><p>如果src是blog/about/index/xxx.jpg   </p><p>就会被添加结合成locahost:4000 /blog/about/  + blog/about/index+xx.jpg</p><p>反正就是前面不能带/   不然就不能补全。     ps(hexo s 可以编译输出 用console.info)</p><pre><code class="javascript">&#39;use strict&#39;;var cheerio = require(&#39;cheerio&#39;);// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123;  return str.split(m, i).join(m).length;&#125;//split这个函数是在str查找m，找到就切分 分成i段，所以会找i-1个 mvar version = String(hexo.version).split(&#39;.&#39;);hexo.extend.filter.register(&#39;after_post_render&#39;, function(data)&#123;  var config = hexo.config;  if(config.post_asset_folder)&#123;        var link = data.permalink;    // if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3)    //    var beginPos = getPosition(link, &#39;/&#39;, 1) + 1;    // else    //    var beginPos = getPosition(link, &#39;/&#39;, 3) + 1;      var beginPos = getPosition(link, &#39;/&#39;, 3) + 1;    var appendLink = &#39;&#39;;    // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.    // if not with index.html endpos = link.lastIndexOf(&#39;.&#39;) + 1 support hexo-abbrlink      // when permalink is end with index.html, for example 2019/02/20/xxtitle/index.html      // image in xxtitle/ will go to xxtitle/index/    var endPos = link.lastIndexOf(&#39;/&#39;);      //public int lastIndexOf(String str): 返回指定子字符串在此字符串中最右边出现处的索引，如果此字符串中没有这样的字符，则返回 -1。      //比如这里本来是https://huatingzhihoudahao.github.io/blog/about/index.html   是截止到about        if(/.*\/index\.html$/.test(link)) &#123;      // when permalink is end with index.html, for example 2019/02/20/xxtitle/index.html      // image in xxtitle/ will go to xxtitle/index/     // appendLink =link.substring(beginPos, endPos)+ &#39;/index/&#39;;     appendLink =&#39;index/&#39;;     //appendLink =&#39;/index/&#39;;         &#125;    else &#123;    &#125;    //link = link.substring(beginPos, endPos) + &#39;/&#39; + appendLink;    link = appendLink;    var toprocess = [&#39;excerpt&#39;, &#39;more&#39;, &#39;content&#39;];    for(var i = 0; i &lt; toprocess.length; i++)    &#123;      var key = toprocess[i];       var $ = cheerio.load(data[key], &#123;        ignoreWhitespace: false,        xmlMode: false,        lowerCaseTags: false,        decodeEntities: false      &#125;);      $(&#39;img&#39;).each      (function()        &#123;                      if ($(this).attr(&#39;src&#39;))//这个意思是返回这个节点（此处为img）的src属性的值                      //src就是xxx.jpg                      //$(this).attr(key); 获取节点属性名的值，相当于getAttribute(key)方法                       &#123;                              // For windows style path, we replace &#39;\&#39; to &#39;/&#39;.                              var src = $(this).attr(&#39;src&#39;).replace(&#39;\\&#39;, &#39;/&#39;); //var是申明变量                              if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp;!/^\s*\//.test(src))                              &#123;                                // For &quot;about&quot; page, the first part of &quot;src&quot; can&#39;t be removed.                                // In addition, to support multi-level local directory.                                var linkArray = link.split(&#39;/&#39;).filter(function(elem)                                //split不改变原本link的值                                                                                      &#123;                                                                                      return elem != &#39;&#39;;                                                                                      &#125;                                                                      );                          //   var srcArray = src.split(&#39;/&#39;).filter(function(elem)                          //                                                       &#123;                          //                                                       return elem != &#39;&#39; &amp;&amp; elem != &#39;.&#39;;                          //                                                       &#125;                          //                                       );                          //   if(srcArray.length &gt; 1)                          //   srcArray.shift();                          //   //shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。                          //  // src = srcArray;                          //   src = srcArray.join(&#39;/&#39;);                               // $(this).attr(&#39;src&#39;,   src);                               console.info&amp;&amp;console.info(link+&quot;&lt;/br&gt;&quot;);                                $(this).attr(&#39;src&#39;,   link+src);                                 //$(this).attr(key, value); 设置节点属性的值，相当于setAttribute(key,value)方法                                 console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+link + src);                              &#125;                      &#125;                      else                      &#123;                        console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;);                        console.info&amp;&amp;console.info($(this));                      &#125;        &#125;      );      data[key] = $.html();    &#125;  &#125;&#125;);</code></pre><p>调试的过程中学了一点点点点js</p><p><img src="js-split.png" alt="G2"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;BUG&lt;/p&gt;
&lt;h2 id=&quot;tips-改完得hexo-clean-g-d-来一趟上传上去（如果搞完了还是没好，可能是网太烂，换一个网8）-如果改了module的js之类的，务必要clean！！！&quot;&gt;&lt;a href=&quot;#tips-改完得hexo-clean-g-d-来一趟</summary>
      
    
    
    
    <category term="hexo" scheme="https://huatingzhihoudahao.github.io/blog/categories/hexo/"/>
    
    
    <category term="-hexo搭建中的bug" scheme="https://huatingzhihoudahao.github.io/blog/tags/hexo%E6%90%AD%E5%BB%BA%E4%B8%AD%E7%9A%84bug/"/>
    
  </entry>
  
  <entry>
    <title>hexo指令</title>
    <link href="https://huatingzhihoudahao.github.io/blog/2021/04/30/hello-world/"/>
    <id>https://huatingzhihoudahao.github.io/blog/2021/04/30/hello-world/</id>
    <published>2021-04-30T12:51:00.746Z</published>
    <updated>2021-05-03T04:31:35.861Z</updated>
    
    <content type="html"><![CDATA[<p>记得指令都在部署git的文件下，我的是myblog 。三件套 hexo clean/ hexo g/ hexo d 不过网不好可能d不上去，再多试试</p><p>host new post xxx   建一个新的md，如果安装hexo-asset-image插件之后会自动创一个同名的文件夹用来放图片</p><p>host new page xxx 建一个新的page，如果想要添加到左边导航栏，需要自己在主题的_config里面更改 比如这个是我用的snark主题的meua  reference是我新加的 。new一个新page然后编译上传之后就会出现一个新的 一大堆前缀/blog/xxx/ 页面可以访问了。</p><pre><code>menu:  - page: 归档    directory: archives/  - page: 分类    directory: categories/  - page: 标签    directory: tags/  - page: 关于    directory: about/  - page: 参考书    directory: reference/  - page: rss    directory: atom.xml</code></pre><p>想插入pdf就百度一下 安一个pdf的插件，然后把pdf扔进source里，想在md里插pdf就写好绝对路径就行</p><p><img src="1.jpg" alt="1"></p><h4 id="Welcome-to-Hexo-This-is-your-very-first-post-Check-documentation-for-more-info-If-you-get-any-problems-when-using-Hexo-you-can-find-the-answer-in-troubleshooting-or-you-can-ask-me-on-GitHub"><a href="#Welcome-to-Hexo-This-is-your-very-first-post-Check-documentation-for-more-info-If-you-get-any-problems-when-using-Hexo-you-can-find-the-answer-in-troubleshooting-or-you-can-ask-me-on-GitHub" class="headerlink" title="Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub."></a>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</h4><h1 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h1><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记得指令都在部署git的文件下，我的是myblog 。三件套 hexo clean/ hexo g/ hexo d 不过网不好可能d不上去，再多试试&lt;/p&gt;
&lt;p&gt;host new post xxx   建一个新的md，如果安装hexo-asset-image插件之后会自动</summary>
      
    
    
    
    <category term="hexo" scheme="https://huatingzhihoudahao.github.io/blog/categories/hexo/"/>
    
    
    <category term="-hexo指令" scheme="https://huatingzhihoudahao.github.io/blog/tags/hexo%E6%8C%87%E4%BB%A4/"/>
    
  </entry>
  
</feed>
